// Code generated from RFC5322Parser.g4 by ANTLR 4.10.1. DO NOT EDIT.

package parser // RFC5322Parser

import (
	"fmt"
	"strconv"
	"sync"

	"github.com/antlr/antlr4/runtime/Go/antlr"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = strconv.Itoa
var _ = sync.Once{}

type RFC5322Parser struct {
	*antlr.BaseParser
}

var rfc5322parserParserStaticData struct {
	once                   sync.Once
	serializedATN          []int32
	literalNames           []string
	symbolicNames          []string
	ruleNames              []string
	predictionContextCache *antlr.PredictionContextCache
	atn                    *antlr.ATN
	decisionToDFA          []*antlr.DFA
}

func rfc5322parserParserInit() {
	staticData := &rfc5322parserParserStaticData
	staticData.literalNames = []string{
		"", "'\\u0000'", "", "'\\t'", "'\\n'", "'\\u000B'", "'\\u000C'", "'\\r'",
		"", "' '", "'!'", "'\"'", "'#'", "'$'", "'%'", "'&'", "'''", "'('",
		"')'", "'*'", "'+'", "','", "'-'", "'.'", "'/'", "", "':'", "';'", "'<'",
		"'='", "'>'", "'?'", "'@'", "'['", "'\\'", "']'", "'^'", "'_'", "'`'",
		"'{'", "'|'", "'}'", "'~'", "'\\u007F'",
	}
	staticData.symbolicNames = []string{
		"", "U_00", "U_01_08", "TAB", "LF", "U_0B", "U_0C", "CR", "U_0E_1F",
		"SP", "Exclamation", "DQuote", "Hash", "Dollar", "Percent", "Ampersand",
		"SQuote", "LParens", "RParens", "Asterisk", "Plus", "Comma", "Minus",
		"Period", "Slash", "Digit", "Colon", "Semicolon", "Less", "Equal", "Greater",
		"Question", "At", "LBracket", "Backslash", "RBracket", "Caret", "Underscore",
		"Backtick", "LCurly", "Pipe", "RCurly", "Tilde", "Delete", "UTF8NonAscii",
		"A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N",
		"O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z",
	}
	staticData.ruleNames = []string{
		"quotedChar", "quotedPair", "fws", "ctext", "ccontent", "comment", "cfws",
		"atext", "atom", "dotAtom", "qtext", "quotedContent", "quotedValue",
		"quotedString", "word", "dateTime", "dayOfweek", "dayName", "day", "month",
		"year", "hour", "minute", "second", "offset", "zone", "address", "mailbox",
		"nameAddr", "angleAddr", "group", "unspaced", "displayName", "mailboxList",
		"addressList", "groupList", "addrSpec", "localPart", "port", "domain",
		"domainLiteral", "dtext", "obsNoWSCTL", "obsCtext", "obsQtext", "obsQP",
		"obsFWS", "obsZone", "obsAngleAddr", "obsRoute", "obsDomainList", "obsMboxList",
		"obsAddrList", "obsGroupList", "obsLocalPart", "obsDomain", "encodedWord",
		"charset", "encoding", "token", "tokenChar", "encodedText", "encodedChar",
		"crlf", "wsp", "vchar", "alpha",
	}
	staticData.predictionContextCache = antlr.NewPredictionContextCache()
	staticData.serializedATN = []int32{
		4, 1, 70, 1027, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4, 7,
		4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10, 7,
		10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7, 15,
		2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20, 2,
		21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2, 26,
		7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31, 7,
		31, 2, 32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7, 36,
		2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7, 39, 2, 40, 7, 40, 2, 41, 7, 41, 2,
		42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2, 46, 7, 46, 2, 47,
		7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52, 7,
		52, 2, 53, 7, 53, 2, 54, 7, 54, 2, 55, 7, 55, 2, 56, 7, 56, 2, 57, 7, 57,
		2, 58, 7, 58, 2, 59, 7, 59, 2, 60, 7, 60, 2, 61, 7, 61, 2, 62, 7, 62, 2,
		63, 7, 63, 2, 64, 7, 64, 2, 65, 7, 65, 2, 66, 7, 66, 1, 0, 1, 0, 3, 0,
		137, 8, 0, 1, 1, 1, 1, 1, 1, 3, 1, 142, 8, 1, 1, 2, 5, 2, 145, 8, 2, 10,
		2, 12, 2, 148, 9, 2, 1, 2, 3, 2, 151, 8, 2, 1, 2, 4, 2, 154, 8, 2, 11,
		2, 12, 2, 155, 1, 2, 3, 2, 159, 8, 2, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1,
		3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1,
		3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1,
		3, 1, 3, 1, 3, 1, 3, 3, 3, 194, 8, 3, 1, 4, 1, 4, 1, 4, 3, 4, 199, 8, 4,
		1, 5, 1, 5, 3, 5, 203, 8, 5, 1, 5, 5, 5, 206, 8, 5, 10, 5, 12, 5, 209,
		9, 5, 1, 5, 3, 5, 212, 8, 5, 1, 5, 1, 5, 1, 6, 3, 6, 217, 8, 6, 1, 6, 4,
		6, 220, 8, 6, 11, 6, 12, 6, 221, 1, 6, 3, 6, 225, 8, 6, 1, 6, 3, 6, 228,
		8, 6, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7,
		1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 3, 7,
		252, 8, 7, 1, 8, 4, 8, 255, 8, 8, 11, 8, 12, 8, 256, 1, 9, 4, 9, 260, 8,
		9, 11, 9, 12, 9, 261, 1, 9, 1, 9, 4, 9, 266, 8, 9, 11, 9, 12, 9, 267, 5,
		9, 270, 8, 9, 10, 9, 12, 9, 273, 9, 9, 1, 9, 3, 9, 276, 8, 9, 1, 10, 1,
		10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10,
		1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1,
		10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10,
		1, 10, 3, 10, 312, 8, 10, 1, 11, 1, 11, 3, 11, 316, 8, 11, 1, 12, 3, 12,
		319, 8, 12, 1, 12, 5, 12, 322, 8, 12, 10, 12, 12, 12, 325, 9, 12, 1, 13,
		1, 13, 1, 13, 3, 13, 330, 8, 13, 1, 13, 1, 13, 1, 14, 3, 14, 335, 8, 14,
		1, 14, 1, 14, 3, 14, 339, 8, 14, 4, 14, 341, 8, 14, 11, 14, 12, 14, 342,
		1, 14, 3, 14, 346, 8, 14, 1, 14, 1, 14, 3, 14, 350, 8, 14, 1, 14, 3, 14,
		353, 8, 14, 1, 14, 1, 14, 3, 14, 357, 8, 14, 3, 14, 359, 8, 14, 1, 15,
		1, 15, 1, 15, 3, 15, 364, 8, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1,
		15, 1, 15, 1, 15, 3, 15, 374, 8, 15, 1, 15, 3, 15, 377, 8, 15, 1, 15, 3,
		15, 380, 8, 15, 1, 15, 1, 15, 1, 16, 3, 16, 385, 8, 16, 1, 16, 1, 16, 3,
		16, 389, 8, 16, 1, 16, 1, 16, 3, 16, 393, 8, 16, 3, 16, 395, 8, 16, 1,
		17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17,
		1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 3,
		17, 418, 8, 17, 1, 18, 3, 18, 421, 8, 18, 1, 18, 1, 18, 3, 18, 425, 8,
		18, 1, 18, 1, 18, 3, 18, 429, 8, 18, 1, 18, 1, 18, 3, 18, 433, 8, 18, 1,
		18, 3, 18, 436, 8, 18, 3, 18, 438, 8, 18, 1, 19, 1, 19, 1, 19, 1, 19, 1,
		19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19,
		1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1,
		19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19,
		3, 19, 476, 8, 19, 1, 20, 1, 20, 1, 20, 1, 20, 1, 20, 1, 20, 1, 20, 1,
		20, 3, 20, 486, 8, 20, 1, 20, 1, 20, 1, 20, 3, 20, 491, 8, 20, 3, 20, 493,
		8, 20, 1, 21, 3, 21, 496, 8, 21, 1, 21, 1, 21, 3, 21, 500, 8, 21, 1, 21,
		3, 21, 503, 8, 21, 1, 21, 1, 21, 3, 21, 507, 8, 21, 3, 21, 509, 8, 21,
		1, 22, 1, 22, 1, 22, 3, 22, 514, 8, 22, 1, 22, 1, 22, 1, 22, 3, 22, 519,
		8, 22, 3, 22, 521, 8, 22, 1, 23, 1, 23, 1, 23, 3, 23, 526, 8, 23, 1, 23,
		1, 23, 1, 23, 3, 23, 531, 8, 23, 3, 23, 533, 8, 23, 1, 24, 3, 24, 536,
		8, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 25, 1, 25, 1, 25, 1, 25, 3,
		25, 547, 8, 25, 1, 26, 1, 26, 3, 26, 551, 8, 26, 1, 27, 1, 27, 3, 27, 555,
		8, 27, 1, 28, 3, 28, 558, 8, 28, 1, 28, 1, 28, 1, 29, 3, 29, 563, 8, 29,
		1, 29, 1, 29, 3, 29, 567, 8, 29, 1, 29, 1, 29, 3, 29, 571, 8, 29, 1, 29,
		3, 29, 574, 8, 29, 1, 30, 3, 30, 577, 8, 30, 1, 30, 1, 30, 1, 30, 3, 30,
		582, 8, 30, 1, 30, 3, 30, 585, 8, 30, 1, 30, 3, 30, 588, 8, 30, 1, 30,
		3, 30, 591, 8, 30, 1, 31, 1, 31, 1, 32, 4, 32, 596, 8, 32, 11, 32, 12,
		32, 597, 1, 32, 1, 32, 1, 32, 1, 32, 5, 32, 604, 8, 32, 10, 32, 12, 32,
		607, 9, 32, 3, 32, 609, 8, 32, 1, 33, 1, 33, 1, 33, 5, 33, 614, 8, 33,
		10, 33, 12, 33, 617, 9, 33, 1, 33, 3, 33, 620, 8, 33, 1, 34, 1, 34, 1,
		34, 5, 34, 625, 8, 34, 10, 34, 12, 34, 628, 9, 34, 1, 34, 1, 34, 1, 34,
		1, 34, 1, 34, 3, 34, 635, 8, 34, 1, 35, 1, 35, 1, 35, 3, 35, 640, 8, 35,
		1, 36, 1, 36, 1, 36, 1, 36, 1, 36, 3, 36, 647, 8, 36, 1, 37, 3, 37, 650,
		8, 37, 1, 37, 1, 37, 3, 37, 654, 8, 37, 1, 37, 3, 37, 657, 8, 37, 1, 37,
		1, 37, 3, 37, 661, 8, 37, 1, 37, 3, 37, 664, 8, 37, 1, 38, 4, 38, 667,
		8, 38, 11, 38, 12, 38, 668, 1, 39, 3, 39, 672, 8, 39, 1, 39, 1, 39, 3,
		39, 676, 8, 39, 1, 39, 3, 39, 679, 8, 39, 1, 39, 1, 39, 3, 39, 683, 8,
		39, 1, 39, 3, 39, 686, 8, 39, 1, 39, 1, 39, 3, 39, 690, 8, 39, 3, 39, 692,
		8, 39, 1, 40, 1, 40, 3, 40, 696, 8, 40, 1, 40, 5, 40, 699, 8, 40, 10, 40,
		12, 40, 702, 9, 40, 1, 40, 3, 40, 705, 8, 40, 1, 40, 1, 40, 1, 41, 1, 41,
		1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1,
		41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41,
		1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 3, 41, 741,
		8, 41, 1, 42, 1, 42, 1, 43, 1, 43, 1, 44, 1, 44, 1, 45, 1, 45, 1, 45, 1,
		45, 1, 45, 3, 45, 754, 8, 45, 1, 46, 4, 46, 757, 8, 46, 11, 46, 12, 46,
		758, 1, 46, 1, 46, 4, 46, 763, 8, 46, 11, 46, 12, 46, 764, 1, 47, 1, 47,
		1, 47, 1, 47, 1, 47, 1, 47, 1, 47, 1, 47, 1, 47, 1, 47, 1, 47, 1, 47, 1,
		47, 1, 47, 1, 47, 1, 47, 1, 47, 1, 47, 1, 47, 1, 47, 1, 47, 1, 47, 1, 47,
		1, 47, 1, 47, 1, 47, 1, 47, 1, 47, 1, 47, 1, 47, 1, 47, 1, 47, 3, 47, 799,
		8, 47, 1, 48, 3, 48, 802, 8, 48, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 3,
		48, 809, 8, 48, 1, 49, 1, 49, 1, 49, 1, 50, 1, 50, 5, 50, 816, 8, 50, 10,
		50, 12, 50, 819, 9, 50, 1, 50, 1, 50, 1, 50, 1, 50, 3, 50, 825, 8, 50,
		1, 50, 1, 50, 3, 50, 829, 8, 50, 5, 50, 831, 8, 50, 10, 50, 12, 50, 834,
		9, 50, 1, 51, 3, 51, 837, 8, 51, 1, 51, 5, 51, 840, 8, 51, 10, 51, 12,
		51, 843, 9, 51, 1, 51, 1, 51, 1, 51, 1, 51, 3, 51, 849, 8, 51, 5, 51, 851,
		8, 51, 10, 51, 12, 51, 854, 9, 51, 1, 52, 3, 52, 857, 8, 52, 1, 52, 5,
		52, 860, 8, 52, 10, 52, 12, 52, 863, 9, 52, 1, 52, 1, 52, 1, 52, 1, 52,
		3, 52, 869, 8, 52, 5, 52, 871, 8, 52, 10, 52, 12, 52, 874, 9, 52, 1, 53,
		3, 53, 877, 8, 53, 1, 53, 4, 53, 880, 8, 53, 11, 53, 12, 53, 881, 1, 53,
		3, 53, 885, 8, 53, 1, 54, 1, 54, 1, 54, 5, 54, 890, 8, 54, 10, 54, 12,
		54, 893, 9, 54, 1, 55, 1, 55, 1, 55, 5, 55, 898, 8, 55, 10, 55, 12, 55,
		901, 9, 55, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1,
		56, 1, 56, 1, 57, 1, 57, 1, 58, 1, 58, 1, 59, 4, 59, 918, 8, 59, 11, 59,
		12, 59, 919, 1, 60, 1, 60, 1, 60, 1, 60, 1, 60, 1, 60, 1, 60, 1, 60, 1,
		60, 1, 60, 1, 60, 1, 60, 1, 60, 1, 60, 1, 60, 1, 60, 1, 60, 1, 60, 1, 60,
		3, 60, 941, 8, 60, 1, 61, 4, 61, 944, 8, 61, 11, 61, 12, 61, 945, 1, 62,
		1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1,
		62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62,
		1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1,
		62, 3, 62, 981, 8, 62, 1, 63, 1, 63, 1, 63, 1, 64, 1, 64, 1, 65, 1, 65,
		1, 65, 1, 65, 1, 65, 1, 65, 1, 65, 1, 65, 1, 65, 1, 65, 1, 65, 1, 65, 1,
		65, 1, 65, 1, 65, 1, 65, 1, 65, 1, 65, 1, 65, 1, 65, 1, 65, 1, 65, 1, 65,
		1, 65, 1, 65, 1, 65, 1, 65, 1, 65, 1, 65, 1, 65, 1, 65, 1, 65, 1, 65, 1,
		65, 1, 65, 3, 65, 1023, 8, 65, 1, 66, 1, 66, 1, 66, 0, 0, 67, 0, 2, 4,
		6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42,
		44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78,
		80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112,
		114, 116, 118, 120, 122, 124, 126, 128, 130, 132, 0, 6, 2, 0, 20, 20, 22,
		22, 2, 0, 23, 23, 32, 32, 2, 0, 21, 21, 27, 27, 4, 0, 2, 2, 5, 6, 8, 8,
		43, 43, 2, 0, 3, 3, 9, 9, 1, 0, 45, 70, 1321, 0, 136, 1, 0, 0, 0, 2, 141,
		1, 0, 0, 0, 4, 158, 1, 0, 0, 0, 6, 193, 1, 0, 0, 0, 8, 198, 1, 0, 0, 0,
		10, 200, 1, 0, 0, 0, 12, 227, 1, 0, 0, 0, 14, 251, 1, 0, 0, 0, 16, 254,
		1, 0, 0, 0, 18, 259, 1, 0, 0, 0, 20, 311, 1, 0, 0, 0, 22, 315, 1, 0, 0,
		0, 24, 323, 1, 0, 0, 0, 26, 326, 1, 0, 0, 0, 28, 358, 1, 0, 0, 0, 30, 363,
		1, 0, 0, 0, 32, 394, 1, 0, 0, 0, 34, 417, 1, 0, 0, 0, 36, 437, 1, 0, 0,
		0, 38, 475, 1, 0, 0, 0, 40, 492, 1, 0, 0, 0, 42, 508, 1, 0, 0, 0, 44, 520,
		1, 0, 0, 0, 46, 532, 1, 0, 0, 0, 48, 535, 1, 0, 0, 0, 50, 546, 1, 0, 0,
		0, 52, 550, 1, 0, 0, 0, 54, 554, 1, 0, 0, 0, 56, 557, 1, 0, 0, 0, 58, 573,
		1, 0, 0, 0, 60, 576, 1, 0, 0, 0, 62, 592, 1, 0, 0, 0, 64, 608, 1, 0, 0,
		0, 66, 619, 1, 0, 0, 0, 68, 634, 1, 0, 0, 0, 70, 639, 1, 0, 0, 0, 72, 641,
		1, 0, 0, 0, 74, 663, 1, 0, 0, 0, 76, 666, 1, 0, 0, 0, 78, 691, 1, 0, 0,
		0, 80, 693, 1, 0, 0, 0, 82, 740, 1, 0, 0, 0, 84, 742, 1, 0, 0, 0, 86, 744,
		1, 0, 0, 0, 88, 746, 1, 0, 0, 0, 90, 748, 1, 0, 0, 0, 92, 756, 1, 0, 0,
		0, 94, 798, 1, 0, 0, 0, 96, 801, 1, 0, 0, 0, 98, 810, 1, 0, 0, 0, 100,
		817, 1, 0, 0, 0, 102, 841, 1, 0, 0, 0, 104, 861, 1, 0, 0, 0, 106, 879,
		1, 0, 0, 0, 108, 886, 1, 0, 0, 0, 110, 894, 1, 0, 0, 0, 112, 902, 1, 0,
		0, 0, 114, 912, 1, 0, 0, 0, 116, 914, 1, 0, 0, 0, 118, 917, 1, 0, 0, 0,
		120, 940, 1, 0, 0, 0, 122, 943, 1, 0, 0, 0, 124, 980, 1, 0, 0, 0, 126,
		982, 1, 0, 0, 0, 128, 985, 1, 0, 0, 0, 130, 1022, 1, 0, 0, 0, 132, 1024,
		1, 0, 0, 0, 134, 137, 3, 130, 65, 0, 135, 137, 3, 128, 64, 0, 136, 134,
		1, 0, 0, 0, 136, 135, 1, 0, 0, 0, 137, 1, 1, 0, 0, 0, 138, 139, 5, 34,
		0, 0, 139, 142, 3, 0, 0, 0, 140, 142, 3, 90, 45, 0, 141, 138, 1, 0, 0,
		0, 141, 140, 1, 0, 0, 0, 142, 3, 1, 0, 0, 0, 143, 145, 3, 128, 64, 0, 144,
		143, 1, 0, 0, 0, 145, 148, 1, 0, 0, 0, 146, 144, 1, 0, 0, 0, 146, 147,
		1, 0, 0, 0, 147, 149, 1, 0, 0, 0, 148, 146, 1, 0, 0, 0, 149, 151, 3, 126,
		63, 0, 150, 146, 1, 0, 0, 0, 150, 151, 1, 0, 0, 0, 151, 153, 1, 0, 0, 0,
		152, 154, 3, 128, 64, 0, 153, 152, 1, 0, 0, 0, 154, 155, 1, 0, 0, 0, 155,
		153, 1, 0, 0, 0, 155, 156, 1, 0, 0, 0, 156, 159, 1, 0, 0, 0, 157, 159,
		3, 92, 46, 0, 158, 150, 1, 0, 0, 0, 158, 157, 1, 0, 0, 0, 159, 5, 1, 0,
		0, 0, 160, 194, 3, 132, 66, 0, 161, 194, 5, 10, 0, 0, 162, 194, 5, 11,
		0, 0, 163, 194, 5, 12, 0, 0, 164, 194, 5, 13, 0, 0, 165, 194, 5, 14, 0,
		0, 166, 194, 5, 15, 0, 0, 167, 194, 5, 16, 0, 0, 168, 194, 5, 19, 0, 0,
		169, 194, 5, 20, 0, 0, 170, 194, 5, 21, 0, 0, 171, 194, 5, 22, 0, 0, 172,
		194, 5, 23, 0, 0, 173, 194, 5, 24, 0, 0, 174, 194, 5, 25, 0, 0, 175, 194,
		5, 26, 0, 0, 176, 194, 5, 27, 0, 0, 177, 194, 5, 28, 0, 0, 178, 194, 5,
		29, 0, 0, 179, 194, 5, 30, 0, 0, 180, 194, 5, 31, 0, 0, 181, 194, 5, 32,
		0, 0, 182, 194, 5, 33, 0, 0, 183, 194, 5, 35, 0, 0, 184, 194, 5, 36, 0,
		0, 185, 194, 5, 37, 0, 0, 186, 194, 5, 38, 0, 0, 187, 194, 5, 39, 0, 0,
		188, 194, 5, 40, 0, 0, 189, 194, 5, 41, 0, 0, 190, 194, 5, 42, 0, 0, 191,
		194, 3, 86, 43, 0, 192, 194, 5, 44, 0, 0, 193, 160, 1, 0, 0, 0, 193, 161,
		1, 0, 0, 0, 193, 162, 1, 0, 0, 0, 193, 163, 1, 0, 0, 0, 193, 164, 1, 0,
		0, 0, 193, 165, 1, 0, 0, 0, 193, 166, 1, 0, 0, 0, 193, 167, 1, 0, 0, 0,
		193, 168, 1, 0, 0, 0, 193, 169, 1, 0, 0, 0, 193, 170, 1, 0, 0, 0, 193,
		171, 1, 0, 0, 0, 193, 172, 1, 0, 0, 0, 193, 173, 1, 0, 0, 0, 193, 174,
		1, 0, 0, 0, 193, 175, 1, 0, 0, 0, 193, 176, 1, 0, 0, 0, 193, 177, 1, 0,
		0, 0, 193, 178, 1, 0, 0, 0, 193, 179, 1, 0, 0, 0, 193, 180, 1, 0, 0, 0,
		193, 181, 1, 0, 0, 0, 193, 182, 1, 0, 0, 0, 193, 183, 1, 0, 0, 0, 193,
		184, 1, 0, 0, 0, 193, 185, 1, 0, 0, 0, 193, 186, 1, 0, 0, 0, 193, 187,
		1, 0, 0, 0, 193, 188, 1, 0, 0, 0, 193, 189, 1, 0, 0, 0, 193, 190, 1, 0,
		0, 0, 193, 191, 1, 0, 0, 0, 193, 192, 1, 0, 0, 0, 194, 7, 1, 0, 0, 0, 195,
		199, 3, 6, 3, 0, 196, 199, 3, 2, 1, 0, 197, 199, 3, 10, 5, 0, 198, 195,
		1, 0, 0, 0, 198, 196, 1, 0, 0, 0, 198, 197, 1, 0, 0, 0, 199, 9, 1, 0, 0,
		0, 200, 207, 5, 17, 0, 0, 201, 203, 3, 4, 2, 0, 202, 201, 1, 0, 0, 0, 202,
		203, 1, 0, 0, 0, 203, 204, 1, 0, 0, 0, 204, 206, 3, 8, 4, 0, 205, 202,
		1, 0, 0, 0, 206, 209, 1, 0, 0, 0, 207, 205, 1, 0, 0, 0, 207, 208, 1, 0,
		0, 0, 208, 211, 1, 0, 0, 0, 209, 207, 1, 0, 0, 0, 210, 212, 3, 4, 2, 0,
		211, 210, 1, 0, 0, 0, 211, 212, 1, 0, 0, 0, 212, 213, 1, 0, 0, 0, 213,
		214, 5, 18, 0, 0, 214, 11, 1, 0, 0, 0, 215, 217, 3, 4, 2, 0, 216, 215,
		1, 0, 0, 0, 216, 217, 1, 0, 0, 0, 217, 218, 1, 0, 0, 0, 218, 220, 3, 10,
		5, 0, 219, 216, 1, 0, 0, 0, 220, 221, 1, 0, 0, 0, 221, 219, 1, 0, 0, 0,
		221, 222, 1, 0, 0, 0, 222, 224, 1, 0, 0, 0, 223, 225, 3, 4, 2, 0, 224,
		223, 1, 0, 0, 0, 224, 225, 1, 0, 0, 0, 225, 228, 1, 0, 0, 0, 226, 228,
		3, 4, 2, 0, 227, 219, 1, 0, 0, 0, 227, 226, 1, 0, 0, 0, 228, 13, 1, 0,
		0, 0, 229, 252, 3, 132, 66, 0, 230, 252, 5, 25, 0, 0, 231, 252, 5, 10,
		0, 0, 232, 252, 5, 12, 0, 0, 233, 252, 5, 13, 0, 0, 234, 252, 5, 14, 0,
		0, 235, 252, 5, 15, 0, 0, 236, 252, 5, 16, 0, 0, 237, 252, 5, 19, 0, 0,
		238, 252, 5, 20, 0, 0, 239, 252, 5, 22, 0, 0, 240, 252, 5, 24, 0, 0, 241,
		252, 5, 29, 0, 0, 242, 252, 5, 31, 0, 0, 243, 252, 5, 36, 0, 0, 244, 252,
		5, 37, 0, 0, 245, 252, 5, 38, 0, 0, 246, 252, 5, 39, 0, 0, 247, 252, 5,
		40, 0, 0, 248, 252, 5, 41, 0, 0, 249, 252, 5, 42, 0, 0, 250, 252, 5, 44,
		0, 0, 251, 229, 1, 0, 0, 0, 251, 230, 1, 0, 0, 0, 251, 231, 1, 0, 0, 0,
		251, 232, 1, 0, 0, 0, 251, 233, 1, 0, 0, 0, 251, 234, 1, 0, 0, 0, 251,
		235, 1, 0, 0, 0, 251, 236, 1, 0, 0, 0, 251, 237, 1, 0, 0, 0, 251, 238,
		1, 0, 0, 0, 251, 239, 1, 0, 0, 0, 251, 240, 1, 0, 0, 0, 251, 241, 1, 0,
		0, 0, 251, 242, 1, 0, 0, 0, 251, 243, 1, 0, 0, 0, 251, 244, 1, 0, 0, 0,
		251, 245, 1, 0, 0, 0, 251, 246, 1, 0, 0, 0, 251, 247, 1, 0, 0, 0, 251,
		248, 1, 0, 0, 0, 251, 249, 1, 0, 0, 0, 251, 250, 1, 0, 0, 0, 252, 15, 1,
		0, 0, 0, 253, 255, 3, 14, 7, 0, 254, 253, 1, 0, 0, 0, 255, 256, 1, 0, 0,
		0, 256, 254, 1, 0, 0, 0, 256, 257, 1, 0, 0, 0, 257, 17, 1, 0, 0, 0, 258,
		260, 3, 14, 7, 0, 259, 258, 1, 0, 0, 0, 260, 261, 1, 0, 0, 0, 261, 259,
		1, 0, 0, 0, 261, 262, 1, 0, 0, 0, 262, 271, 1, 0, 0, 0, 263, 265, 5, 23,
		0, 0, 264, 266, 3, 14, 7, 0, 265, 264, 1, 0, 0, 0, 266, 267, 1, 0, 0, 0,
		267, 265, 1, 0, 0, 0, 267, 268, 1, 0, 0, 0, 268, 270, 1, 0, 0, 0, 269,
		263, 1, 0, 0, 0, 270, 273, 1, 0, 0, 0, 271, 269, 1, 0, 0, 0, 271, 272,
		1, 0, 0, 0, 272, 275, 1, 0, 0, 0, 273, 271, 1, 0, 0, 0, 274, 276, 5, 23,
		0, 0, 275, 274, 1, 0, 0, 0, 275, 276, 1, 0, 0, 0, 276, 19, 1, 0, 0, 0,
		277, 312, 3, 132, 66, 0, 278, 312, 5, 10, 0, 0, 279, 312, 5, 12, 0, 0,
		280, 312, 5, 13, 0, 0, 281, 312, 5, 14, 0, 0, 282, 312, 5, 15, 0, 0, 283,
		312, 5, 16, 0, 0, 284, 312, 5, 17, 0, 0, 285, 312, 5, 18, 0, 0, 286, 312,
		5, 19, 0, 0, 287, 312, 5, 20, 0, 0, 288, 312, 5, 21, 0, 0, 289, 312, 5,
		22, 0, 0, 290, 312, 5, 23, 0, 0, 291, 312, 5, 24, 0, 0, 292, 312, 5, 25,
		0, 0, 293, 312, 5, 26, 0, 0, 294, 312, 5, 27, 0, 0, 295, 312, 5, 28, 0,
		0, 296, 312, 5, 29, 0, 0, 297, 312, 5, 30, 0, 0, 298, 312, 5, 31, 0, 0,
		299, 312, 5, 32, 0, 0, 300, 312, 5, 33, 0, 0, 301, 312, 5, 35, 0, 0, 302,
		312, 5, 36, 0, 0, 303, 312, 5, 37, 0, 0, 304, 312, 5, 38, 0, 0, 305, 312,
		5, 39, 0, 0, 306, 312, 5, 40, 0, 0, 307, 312, 5, 41, 0, 0, 308, 312, 5,
		42, 0, 0, 309, 312, 3, 88, 44, 0, 310, 312, 5, 44, 0, 0, 311, 277, 1, 0,
		0, 0, 311, 278, 1, 0, 0, 0, 311, 279, 1, 0, 0, 0, 311, 280, 1, 0, 0, 0,
		311, 281, 1, 0, 0, 0, 311, 282, 1, 0, 0, 0, 311, 283, 1, 0, 0, 0, 311,
		284, 1, 0, 0, 0, 311, 285, 1, 0, 0, 0, 311, 286, 1, 0, 0, 0, 311, 287,
		1, 0, 0, 0, 311, 288, 1, 0, 0, 0, 311, 289, 1, 0, 0, 0, 311, 290, 1, 0,
		0, 0, 311, 291, 1, 0, 0, 0, 311, 292, 1, 0, 0, 0, 311, 293, 1, 0, 0, 0,
		311, 294, 1, 0, 0, 0, 311, 295, 1, 0, 0, 0, 311, 296, 1, 0, 0, 0, 311,
		297, 1, 0, 0, 0, 311, 298, 1, 0, 0, 0, 311, 299, 1, 0, 0, 0, 311, 300,
		1, 0, 0, 0, 311, 301, 1, 0, 0, 0, 311, 302, 1, 0, 0, 0, 311, 303, 1, 0,
		0, 0, 311, 304, 1, 0, 0, 0, 311, 305, 1, 0, 0, 0, 311, 306, 1, 0, 0, 0,
		311, 307, 1, 0, 0, 0, 311, 308, 1, 0, 0, 0, 311, 309, 1, 0, 0, 0, 311,
		310, 1, 0, 0, 0, 312, 21, 1, 0, 0, 0, 313, 316, 3, 20, 10, 0, 314, 316,
		3, 2, 1, 0, 315, 313, 1, 0, 0, 0, 315, 314, 1, 0, 0, 0, 316, 23, 1, 0,
		0, 0, 317, 319, 3, 4, 2, 0, 318, 317, 1, 0, 0, 0, 318, 319, 1, 0, 0, 0,
		319, 320, 1, 0, 0, 0, 320, 322, 3, 22, 11, 0, 321, 318, 1, 0, 0, 0, 322,
		325, 1, 0, 0, 0, 323, 321, 1, 0, 0, 0, 323, 324, 1, 0, 0, 0, 324, 25, 1,
		0, 0, 0, 325, 323, 1, 0, 0, 0, 326, 327, 5, 11, 0, 0, 327, 329, 3, 24,
		12, 0, 328, 330, 3, 4, 2, 0, 329, 328, 1, 0, 0, 0, 329, 330, 1, 0, 0, 0,
		330, 331, 1, 0, 0, 0, 331, 332, 5, 11, 0, 0, 332, 27, 1, 0, 0, 0, 333,
		335, 3, 12, 6, 0, 334, 333, 1, 0, 0, 0, 334, 335, 1, 0, 0, 0, 335, 336,
		1, 0, 0, 0, 336, 338, 3, 112, 56, 0, 337, 339, 3, 12, 6, 0, 338, 337, 1,
		0, 0, 0, 338, 339, 1, 0, 0, 0, 339, 341, 1, 0, 0, 0, 340, 334, 1, 0, 0,
		0, 341, 342, 1, 0, 0, 0, 342, 340, 1, 0, 0, 0, 342, 343, 1, 0, 0, 0, 343,
		359, 1, 0, 0, 0, 344, 346, 3, 12, 6, 0, 345, 344, 1, 0, 0, 0, 345, 346,
		1, 0, 0, 0, 346, 347, 1, 0, 0, 0, 347, 349, 3, 16, 8, 0, 348, 350, 3, 12,
		6, 0, 349, 348, 1, 0, 0, 0, 349, 350, 1, 0, 0, 0, 350, 359, 1, 0, 0, 0,
		351, 353, 3, 12, 6, 0, 352, 351, 1, 0, 0, 0, 352, 353, 1, 0, 0, 0, 353,
		354, 1, 0, 0, 0, 354, 356, 3, 26, 13, 0, 355, 357, 3, 12, 6, 0, 356, 355,
		1, 0, 0, 0, 356, 357, 1, 0, 0, 0, 357, 359, 1, 0, 0, 0, 358, 340, 1, 0,
		0, 0, 358, 345, 1, 0, 0, 0, 358, 352, 1, 0, 0, 0, 359, 29, 1, 0, 0, 0,
		360, 361, 3, 32, 16, 0, 361, 362, 5, 21, 0, 0, 362, 364, 1, 0, 0, 0, 363,
		360, 1, 0, 0, 0, 363, 364, 1, 0, 0, 0, 364, 365, 1, 0, 0, 0, 365, 366,
		3, 36, 18, 0, 366, 367, 3, 38, 19, 0, 367, 368, 3, 40, 20, 0, 368, 369,
		3, 42, 21, 0, 369, 370, 5, 26, 0, 0, 370, 373, 3, 44, 22, 0, 371, 372,
		5, 26, 0, 0, 372, 374, 3, 46, 23, 0, 373, 371, 1, 0, 0, 0, 373, 374, 1,
		0, 0, 0, 374, 376, 1, 0, 0, 0, 375, 377, 3, 50, 25, 0, 376, 375, 1, 0,
		0, 0, 376, 377, 1, 0, 0, 0, 377, 379, 1, 0, 0, 0, 378, 380, 3, 12, 6, 0,
		379, 378, 1, 0, 0, 0, 379, 380, 1, 0, 0, 0, 380, 381, 1, 0, 0, 0, 381,
		382, 5, 0, 0, 1, 382, 31, 1, 0, 0, 0, 383, 385, 3, 4, 2, 0, 384, 383, 1,
		0, 0, 0, 384, 385, 1, 0, 0, 0, 385, 386, 1, 0, 0, 0, 386, 395, 3, 34, 17,
		0, 387, 389, 3, 12, 6, 0, 388, 387, 1, 0, 0, 0, 388, 389, 1, 0, 0, 0, 389,
		390, 1, 0, 0, 0, 390, 392, 3, 34, 17, 0, 391, 393, 3, 12, 6, 0, 392, 391,
		1, 0, 0, 0, 392, 393, 1, 0, 0, 0, 393, 395, 1, 0, 0, 0, 394, 384, 1, 0,
		0, 0, 394, 388, 1, 0, 0, 0, 395, 33, 1, 0, 0, 0, 396, 397, 5, 57, 0, 0,
		397, 398, 5, 59, 0, 0, 398, 418, 5, 58, 0, 0, 399, 400, 5, 64, 0, 0, 400,
		401, 5, 65, 0, 0, 401, 418, 5, 49, 0, 0, 402, 403, 5, 67, 0, 0, 403, 404,
		5, 49, 0, 0, 404, 418, 5, 48, 0, 0, 405, 406, 5, 64, 0, 0, 406, 407, 5,
		52, 0, 0, 407, 418, 5, 65, 0, 0, 408, 409, 5, 50, 0, 0, 409, 410, 5, 62,
		0, 0, 410, 418, 5, 53, 0, 0, 411, 412, 5, 63, 0, 0, 412, 413, 5, 45, 0,
		0, 413, 418, 5, 64, 0, 0, 414, 415, 5, 63, 0, 0, 415, 416, 5, 65, 0, 0,
		416, 418, 5, 58, 0, 0, 417, 396, 1, 0, 0, 0, 417, 399, 1, 0, 0, 0, 417,
		402, 1, 0, 0, 0, 417, 405, 1, 0, 0, 0, 417, 408, 1, 0, 0, 0, 417, 411,
		1, 0, 0, 0, 417, 414, 1, 0, 0, 0, 418, 35, 1, 0, 0, 0, 419, 421, 3, 4,
		2, 0, 420, 419, 1, 0, 0, 0, 420, 421, 1, 0, 0, 0, 421, 422, 1, 0, 0, 0,
		422, 424, 5, 25, 0, 0, 423, 425, 5, 25, 0, 0, 424, 423, 1, 0, 0, 0, 424,
		425, 1, 0, 0, 0, 425, 426, 1, 0, 0, 0, 426, 438, 3, 4, 2, 0, 427, 429,
		3, 12, 6, 0, 428, 427, 1, 0, 0, 0, 428, 429, 1, 0, 0, 0, 429, 430, 1, 0,
		0, 0, 430, 432, 5, 25, 0, 0, 431, 433, 5, 25, 0, 0, 432, 431, 1, 0, 0,
		0, 432, 433, 1, 0, 0, 0, 433, 435, 1, 0, 0, 0, 434, 436, 3, 12, 6, 0, 435,
		434, 1, 0, 0, 0, 435, 436, 1, 0, 0, 0, 436, 438, 1, 0, 0, 0, 437, 420,
		1, 0, 0, 0, 437, 428, 1, 0, 0, 0, 438, 37, 1, 0, 0, 0, 439, 440, 5, 54,
		0, 0, 440, 441, 5, 45, 0, 0, 441, 476, 5, 58, 0, 0, 442, 443, 5, 50, 0,
		0, 443, 444, 5, 49, 0, 0, 444, 476, 5, 46, 0, 0, 445, 446, 5, 57, 0, 0,
		446, 447, 5, 45, 0, 0, 447, 476, 5, 62, 0, 0, 448, 449, 5, 45, 0, 0, 449,
		450, 5, 60, 0, 0, 450, 476, 5, 62, 0, 0, 451, 452, 5, 57, 0, 0, 452, 453,
		5, 45, 0, 0, 453, 476, 5, 69, 0, 0, 454, 455, 5, 54, 0, 0, 455, 456, 5,
		65, 0, 0, 456, 476, 5, 58, 0, 0, 457, 458, 5, 54, 0, 0, 458, 459, 5, 65,
		0, 0, 459, 476, 5, 56, 0, 0, 460, 461, 5, 45, 0, 0, 461, 462, 5, 65, 0,
		0, 462, 476, 5, 51, 0, 0, 463, 464, 5, 63, 0, 0, 464, 465, 5, 49, 0, 0,
		465, 476, 5, 60, 0, 0, 466, 467, 5, 59, 0, 0, 467, 468, 5, 47, 0, 0, 468,
		476, 5, 64, 0, 0, 469, 470, 5, 58, 0, 0, 470, 471, 5, 59, 0, 0, 471, 476,
		5, 66, 0, 0, 472, 473, 5, 48, 0, 0, 473, 474, 5, 49, 0, 0, 474, 476, 5,
		47, 0, 0, 475, 439, 1, 0, 0, 0, 475, 442, 1, 0, 0, 0, 475, 445, 1, 0, 0,
		0, 475, 448, 1, 0, 0, 0, 475, 451, 1, 0, 0, 0, 475, 454, 1, 0, 0, 0, 475,
		457, 1, 0, 0, 0, 475, 460, 1, 0, 0, 0, 475, 463, 1, 0, 0, 0, 475, 466,
		1, 0, 0, 0, 475, 469, 1, 0, 0, 0, 475, 472, 1, 0, 0, 0, 476, 39, 1, 0,
		0, 0, 477, 478, 3, 4, 2, 0, 478, 479, 5, 25, 0, 0, 479, 480, 5, 25, 0,
		0, 480, 481, 5, 25, 0, 0, 481, 482, 5, 25, 0, 0, 482, 483, 3, 4, 2, 0,
		483, 493, 1, 0, 0, 0, 484, 486, 3, 12, 6, 0, 485, 484, 1, 0, 0, 0, 485,
		486, 1, 0, 0, 0, 486, 487, 1, 0, 0, 0, 487, 488, 5, 25, 0, 0, 488, 490,
		5, 25, 0, 0, 489, 491, 3, 12, 6, 0, 490, 489, 1, 0, 0, 0, 490, 491, 1,
		0, 0, 0, 491, 493, 1, 0, 0, 0, 492, 477, 1, 0, 0, 0, 492, 485, 1, 0, 0,
		0, 493, 41, 1, 0, 0, 0, 494, 496, 5, 25, 0, 0, 495, 494, 1, 0, 0, 0, 495,
		496, 1, 0, 0, 0, 496, 497, 1, 0, 0, 0, 497, 509, 5, 25, 0, 0, 498, 500,
		3, 12, 6, 0, 499, 498, 1, 0, 0, 0, 499, 500, 1, 0, 0, 0, 500, 502, 1, 0,
		0, 0, 501, 503, 5, 25, 0, 0, 502, 501, 1, 0, 0, 0, 502, 503, 1, 0, 0, 0,
		503, 504, 1, 0, 0, 0, 504, 506, 5, 25, 0, 0, 505, 507, 3, 12, 6, 0, 506,
		505, 1, 0, 0, 0, 506, 507, 1, 0, 0, 0, 507, 509, 1, 0, 0, 0, 508, 495,
		1, 0, 0, 0, 508, 499, 1, 0, 0, 0, 509, 43, 1, 0, 0, 0, 510, 511, 5, 25,
		0, 0, 511, 521, 5, 25, 0, 0, 512, 514, 3, 12, 6, 0, 513, 512, 1, 0, 0,
		0, 513, 514, 1, 0, 0, 0, 514, 515, 1, 0, 0, 0, 515, 516, 5, 25, 0, 0, 516,
		518, 5, 25, 0, 0, 517, 519, 3, 12, 6, 0, 518, 517, 1, 0, 0, 0, 518, 519,
		1, 0, 0, 0, 519, 521, 1, 0, 0, 0, 520, 510, 1, 0, 0, 0, 520, 513, 1, 0,
		0, 0, 521, 45, 1, 0, 0, 0, 522, 523, 5, 25, 0, 0, 523, 533, 5, 25, 0, 0,
		524, 526, 3, 12, 6, 0, 525, 524, 1, 0, 0, 0, 525, 526, 1, 0, 0, 0, 526,
		527, 1, 0, 0, 0, 527, 528, 5, 25, 0, 0, 528, 530, 5, 25, 0, 0, 529, 531,
		3, 12, 6, 0, 530, 529, 1, 0, 0, 0, 530, 531, 1, 0, 0, 0, 531, 533, 1, 0,
		0, 0, 532, 522, 1, 0, 0, 0, 532, 525, 1, 0, 0, 0, 533, 47, 1, 0, 0, 0,
		534, 536, 7, 0, 0, 0, 535, 534, 1, 0, 0, 0, 535, 536, 1, 0, 0, 0, 536,
		537, 1, 0, 0, 0, 537, 538, 5, 25, 0, 0, 538, 539, 5, 25, 0, 0, 539, 540,
		5, 25, 0, 0, 540, 541, 5, 25, 0, 0, 541, 49, 1, 0, 0, 0, 542, 543, 3, 4,
		2, 0, 543, 544, 3, 48, 24, 0, 544, 547, 1, 0, 0, 0, 545, 547, 3, 94, 47,
		0, 546, 542, 1, 0, 0, 0, 546, 545, 1, 0, 0, 0, 547, 51, 1, 0, 0, 0, 548,
		551, 3, 54, 27, 0, 549, 551, 3, 60, 30, 0, 550, 548, 1, 0, 0, 0, 550, 549,
		1, 0, 0, 0, 551, 53, 1, 0, 0, 0, 552, 555, 3, 56, 28, 0, 553, 555, 3, 72,
		36, 0, 554, 552, 1, 0, 0, 0, 554, 553, 1, 0, 0, 0, 555, 55, 1, 0, 0, 0,
		556, 558, 3, 64, 32, 0, 557, 556, 1, 0, 0, 0, 557, 558, 1, 0, 0, 0, 558,
		559, 1, 0, 0, 0, 559, 560, 3, 58, 29, 0, 560, 57, 1, 0, 0, 0, 561, 563,
		3, 12, 6, 0, 562, 561, 1, 0, 0, 0, 562, 563, 1, 0, 0, 0, 563, 564, 1, 0,
		0, 0, 564, 566, 5, 28, 0, 0, 565, 567, 3, 72, 36, 0, 566, 565, 1, 0, 0,
		0, 566, 567, 1, 0, 0, 0, 567, 568, 1, 0, 0, 0, 568, 570, 5, 30, 0, 0, 569,
		571, 3, 12, 6, 0, 570, 569, 1, 0, 0, 0, 570, 571, 1, 0, 0, 0, 571, 574,
		1, 0, 0, 0, 572, 574, 3, 96, 48, 0, 573, 562, 1, 0, 0, 0, 573, 572, 1,
		0, 0, 0, 574, 59, 1, 0, 0, 0, 575, 577, 5, 11, 0, 0, 576, 575, 1, 0, 0,
		0, 576, 577, 1, 0, 0, 0, 577, 578, 1, 0, 0, 0, 578, 579, 3, 64, 32, 0,
		579, 581, 5, 26, 0, 0, 580, 582, 3, 70, 35, 0, 581, 580, 1, 0, 0, 0, 581,
		582, 1, 0, 0, 0, 582, 584, 1, 0, 0, 0, 583, 585, 5, 11, 0, 0, 584, 583,
		1, 0, 0, 0, 584, 585, 1, 0, 0, 0, 585, 587, 1, 0, 0, 0, 586, 588, 5, 27,
		0, 0, 587, 586, 1, 0, 0, 0, 587, 588, 1, 0, 0, 0, 588, 590, 1, 0, 0, 0,
		589, 591, 3, 12, 6, 0, 590, 589, 1, 0, 0, 0, 590, 591, 1, 0, 0, 0, 591,
		61, 1, 0, 0, 0, 592, 593, 7, 1, 0, 0, 593, 63, 1, 0, 0, 0, 594, 596, 3,
		28, 14, 0, 595, 594, 1, 0, 0, 0, 596, 597, 1, 0, 0, 0, 597, 595, 1, 0,
		0, 0, 597, 598, 1, 0, 0, 0, 598, 609, 1, 0, 0, 0, 599, 605, 3, 28, 14,
		0, 600, 604, 3, 28, 14, 0, 601, 604, 3, 62, 31, 0, 602, 604, 3, 12, 6,
		0, 603, 600, 1, 0, 0, 0, 603, 601, 1, 0, 0, 0, 603, 602, 1, 0, 0, 0, 604,
		607, 1, 0, 0, 0, 605, 603, 1, 0, 0, 0, 605, 606, 1, 0, 0, 0, 606, 609,
		1, 0, 0, 0, 607, 605, 1, 0, 0, 0, 608, 595, 1, 0, 0, 0, 608, 599, 1, 0,
		0, 0, 609, 65, 1, 0, 0, 0, 610, 615, 3, 54, 27, 0, 611, 612, 5, 21, 0,
		0, 612, 614, 3, 54, 27, 0, 613, 611, 1, 0, 0, 0, 614, 617, 1, 0, 0, 0,
		615, 613, 1, 0, 0, 0, 615, 616, 1, 0, 0, 0, 616, 620, 1, 0, 0, 0, 617,
		615, 1, 0, 0, 0, 618, 620, 3, 102, 51, 0, 619, 610, 1, 0, 0, 0, 619, 618,
		1, 0, 0, 0, 620, 67, 1, 0, 0, 0, 621, 626, 3, 52, 26, 0, 622, 623, 7, 2,
		0, 0, 623, 625, 3, 52, 26, 0, 624, 622, 1, 0, 0, 0, 625, 628, 1, 0, 0,
		0, 626, 624, 1, 0, 0, 0, 626, 627, 1, 0, 0, 0, 627, 629, 1, 0, 0, 0, 628,
		626, 1, 0, 0, 0, 629, 630, 5, 0, 0, 1, 630, 635, 1, 0, 0, 0, 631, 632,
		3, 104, 52, 0, 632, 633, 5, 0, 0, 1, 633, 635, 1, 0, 0, 0, 634, 621, 1,
		0, 0, 0, 634, 631, 1, 0, 0, 0, 635, 69, 1, 0, 0, 0, 636, 640, 3, 66, 33,
		0, 637, 640, 3, 12, 6, 0, 638, 640, 3, 106, 53, 0, 639, 636, 1, 0, 0, 0,
		639, 637, 1, 0, 0, 0, 639, 638, 1, 0, 0, 0, 640, 71, 1, 0, 0, 0, 641, 642,
		3, 74, 37, 0, 642, 643, 5, 32, 0, 0, 643, 646, 3, 78, 39, 0, 644, 645,
		5, 26, 0, 0, 645, 647, 3, 76, 38, 0, 646, 644, 1, 0, 0, 0, 646, 647, 1,
		0, 0, 0, 647, 73, 1, 0, 0, 0, 648, 650, 3, 12, 6, 0, 649, 648, 1, 0, 0,
		0, 649, 650, 1, 0, 0, 0, 650, 651, 1, 0, 0, 0, 651, 653, 3, 18, 9, 0, 652,
		654, 3, 12, 6, 0, 653, 652, 1, 0, 0, 0, 653, 654, 1, 0, 0, 0, 654, 664,
		1, 0, 0, 0, 655, 657, 3, 12, 6, 0, 656, 655, 1, 0, 0, 0, 656, 657, 1, 0,
		0, 0, 657, 658, 1, 0, 0, 0, 658, 660, 3, 26, 13, 0, 659, 661, 3, 12, 6,
		0, 660, 659, 1, 0, 0, 0, 660, 661, 1, 0, 0, 0, 661, 664, 1, 0, 0, 0, 662,
		664, 3, 108, 54, 0, 663, 649, 1, 0, 0, 0, 663, 656, 1, 0, 0, 0, 663, 662,
		1, 0, 0, 0, 664, 75, 1, 0, 0, 0, 665, 667, 5, 25, 0, 0, 666, 665, 1, 0,
		0, 0, 667, 668, 1, 0, 0, 0, 668, 666, 1, 0, 0, 0, 668, 669, 1, 0, 0, 0,
		669, 77, 1, 0, 0, 0, 670, 672, 3, 12, 6, 0, 671, 670, 1, 0, 0, 0, 671,
		672, 1, 0, 0, 0, 672, 673, 1, 0, 0, 0, 673, 675, 3, 18, 9, 0, 674, 676,
		3, 12, 6, 0, 675, 674, 1, 0, 0, 0, 675, 676, 1, 0, 0, 0, 676, 692, 1, 0,
		0, 0, 677, 679, 3, 12, 6, 0, 678, 677, 1, 0, 0, 0, 678, 679, 1, 0, 0, 0,
		679, 680, 1, 0, 0, 0, 680, 682, 3, 80, 40, 0, 681, 683, 3, 12, 6, 0, 682,
		681, 1, 0, 0, 0, 682, 683, 1, 0, 0, 0, 683, 692, 1, 0, 0, 0, 684, 686,
		3, 12, 6, 0, 685, 684, 1, 0, 0, 0, 685, 686, 1, 0, 0, 0, 686, 687, 1, 0,
		0, 0, 687, 689, 3, 110, 55, 0, 688, 690, 3, 12, 6, 0, 689, 688, 1, 0, 0,
		0, 689, 690, 1, 0, 0, 0, 690, 692, 1, 0, 0, 0, 691, 671, 1, 0, 0, 0, 691,
		678, 1, 0, 0, 0, 691, 685, 1, 0, 0, 0, 692, 79, 1, 0, 0, 0, 693, 700, 5,
		33, 0, 0, 694, 696, 3, 4, 2, 0, 695, 694, 1, 0, 0, 0, 695, 696, 1, 0, 0,
		0, 696, 697, 1, 0, 0, 0, 697, 699, 3, 82, 41, 0, 698, 695, 1, 0, 0, 0,
		699, 702, 1, 0, 0, 0, 700, 698, 1, 0, 0, 0, 700, 701, 1, 0, 0, 0, 701,
		704, 1, 0, 0, 0, 702, 700, 1, 0, 0, 0, 703, 705, 3, 4, 2, 0, 704, 703,
		1, 0, 0, 0, 704, 705, 1, 0, 0, 0, 705, 706, 1, 0, 0, 0, 706, 707, 5, 35,
		0, 0, 707, 81, 1, 0, 0, 0, 708, 741, 3, 132, 66, 0, 709, 741, 5, 10, 0,
		0, 710, 741, 5, 11, 0, 0, 711, 741, 5, 12, 0, 0, 712, 741, 5, 13, 0, 0,
		713, 741, 5, 14, 0, 0, 714, 741, 5, 15, 0, 0, 715, 741, 5, 16, 0, 0, 716,
		741, 5, 17, 0, 0, 717, 741, 5, 18, 0, 0, 718, 741, 5, 19, 0, 0, 719, 741,
		5, 20, 0, 0, 720, 741, 5, 21, 0, 0, 721, 741, 5, 22, 0, 0, 722, 741, 5,
		23, 0, 0, 723, 741, 5, 24, 0, 0, 724, 741, 5, 25, 0, 0, 725, 741, 5, 26,
		0, 0, 726, 741, 5, 27, 0, 0, 727, 741, 5, 28, 0, 0, 728, 741, 5, 29, 0,
		0, 729, 741, 5, 30, 0, 0, 730, 741, 5, 31, 0, 0, 731, 741, 5, 32, 0, 0,
		732, 741, 5, 36, 0, 0, 733, 741, 5, 37, 0, 0, 734, 741, 5, 38, 0, 0, 735,
		741, 5, 39, 0, 0, 736, 741, 5, 40, 0, 0, 737, 741, 5, 41, 0, 0, 738, 741,
		5, 42, 0, 0, 739, 741, 5, 44, 0, 0, 740, 708, 1, 0, 0, 0, 740, 709, 1,
		0, 0, 0, 740, 710, 1, 0, 0, 0, 740, 711, 1, 0, 0, 0, 740, 712, 1, 0, 0,
		0, 740, 713, 1, 0, 0, 0, 740, 714, 1, 0, 0, 0, 740, 715, 1, 0, 0, 0, 740,
		716, 1, 0, 0, 0, 740, 717, 1, 0, 0, 0, 740, 718, 1, 0, 0, 0, 740, 719,
		1, 0, 0, 0, 740, 720, 1, 0, 0, 0, 740, 721, 1, 0, 0, 0, 740, 722, 1, 0,
		0, 0, 740, 723, 1, 0, 0, 0, 740, 724, 1, 0, 0, 0, 740, 725, 1, 0, 0, 0,
		740, 726, 1, 0, 0, 0, 740, 727, 1, 0, 0, 0, 740, 728, 1, 0, 0, 0, 740,
		729, 1, 0, 0, 0, 740, 730, 1, 0, 0, 0, 740, 731, 1, 0, 0, 0, 740, 732,
		1, 0, 0, 0, 740, 733, 1, 0, 0, 0, 740, 734, 1, 0, 0, 0, 740, 735, 1, 0,
		0, 0, 740, 736, 1, 0, 0, 0, 740, 737, 1, 0, 0, 0, 740, 738, 1, 0, 0, 0,
		740, 739, 1, 0, 0, 0, 741, 83, 1, 0, 0, 0, 742, 743, 7, 3, 0, 0, 743, 85,
		1, 0, 0, 0, 744, 745, 3, 84, 42, 0, 745, 87, 1, 0, 0, 0, 746, 747, 3, 84,
		42, 0, 747, 89, 1, 0, 0, 0, 748, 753, 5, 34, 0, 0, 749, 754, 5, 1, 0, 0,
		750, 754, 3, 84, 42, 0, 751, 754, 5, 4, 0, 0, 752, 754, 5, 7, 0, 0, 753,
		749, 1, 0, 0, 0, 753, 750, 1, 0, 0, 0, 753, 751, 1, 0, 0, 0, 753, 752,
		1, 0, 0, 0, 754, 91, 1, 0, 0, 0, 755, 757, 3, 128, 64, 0, 756, 755, 1,
		0, 0, 0, 757, 758, 1, 0, 0, 0, 758, 756, 1, 0, 0, 0, 758, 759, 1, 0, 0,
		0, 759, 760, 1, 0, 0, 0, 760, 762, 3, 126, 63, 0, 761, 763, 3, 128, 64,
		0, 762, 761, 1, 0, 0, 0, 763, 764, 1, 0, 0, 0, 764, 762, 1, 0, 0, 0, 764,
		765, 1, 0, 0, 0, 765, 93, 1, 0, 0, 0, 766, 767, 5, 65, 0, 0, 767, 799,
		5, 64, 0, 0, 768, 769, 5, 65, 0, 0, 769, 770, 5, 64, 0, 0, 770, 799, 5,
		47, 0, 0, 771, 772, 5, 51, 0, 0, 772, 773, 5, 57, 0, 0, 773, 799, 5, 64,
		0, 0, 774, 775, 5, 49, 0, 0, 775, 776, 5, 63, 0, 0, 776, 799, 5, 64, 0,
		0, 777, 778, 5, 49, 0, 0, 778, 779, 5, 48, 0, 0, 779, 799, 5, 64, 0, 0,
		780, 781, 5, 47, 0, 0, 781, 782, 5, 63, 0, 0, 782, 799, 5, 64, 0, 0, 783,
		784, 5, 47, 0, 0, 784, 785, 5, 48, 0, 0, 785, 799, 5, 64, 0, 0, 786, 787,
		5, 57, 0, 0, 787, 788, 5, 63, 0, 0, 788, 799, 5, 64, 0, 0, 789, 790, 5,
		57, 0, 0, 790, 791, 5, 48, 0, 0, 791, 799, 5, 64, 0, 0, 792, 793, 5, 60,
		0, 0, 793, 794, 5, 63, 0, 0, 794, 799, 5, 64, 0, 0, 795, 796, 5, 60, 0,
		0, 796, 797, 5, 48, 0, 0, 797, 799, 5, 64, 0, 0, 798, 766, 1, 0, 0, 0,
		798, 768, 1, 0, 0, 0, 798, 771, 1, 0, 0, 0, 798, 774, 1, 0, 0, 0, 798,
		777, 1, 0, 0, 0, 798, 780, 1, 0, 0, 0, 798, 783, 1, 0, 0, 0, 798, 786,
		1, 0, 0, 0, 798, 789, 1, 0, 0, 0, 798, 792, 1, 0, 0, 0, 798, 795, 1, 0,
		0, 0, 799, 95, 1, 0, 0, 0, 800, 802, 3, 12, 6, 0, 801, 800, 1, 0, 0, 0,
		801, 802, 1, 0, 0, 0, 802, 803, 1, 0, 0, 0, 803, 804, 5, 28, 0, 0, 804,
		805, 3, 98, 49, 0, 805, 806, 3, 72, 36, 0, 806, 808, 5, 30, 0, 0, 807,
		809, 3, 12, 6, 0, 808, 807, 1, 0, 0, 0, 808, 809, 1, 0, 0, 0, 809, 97,
		1, 0, 0, 0, 810, 811, 3, 100, 50, 0, 811, 812, 5, 26, 0, 0, 812, 99, 1,
		0, 0, 0, 813, 816, 3, 12, 6, 0, 814, 816, 5, 21, 0, 0, 815, 813, 1, 0,
		0, 0, 815, 814, 1, 0, 0, 0, 816, 819, 1, 0, 0, 0, 817, 815, 1, 0, 0, 0,
		817, 818, 1, 0, 0, 0, 818, 820, 1, 0, 0, 0, 819, 817, 1, 0, 0, 0, 820,
		821, 5, 32, 0, 0, 821, 832, 3, 78, 39, 0, 822, 824, 5, 21, 0, 0, 823, 825,
		3, 12, 6, 0, 824, 823, 1, 0, 0, 0, 824, 825, 1, 0, 0, 0, 825, 828, 1, 0,
		0, 0, 826, 827, 5, 32, 0, 0, 827, 829, 3, 78, 39, 0, 828, 826, 1, 0, 0,
		0, 828, 829, 1, 0, 0, 0, 829, 831, 1, 0, 0, 0, 830, 822, 1, 0, 0, 0, 831,
		834, 1, 0, 0, 0, 832, 830, 1, 0, 0, 0, 832, 833, 1, 0, 0, 0, 833, 101,
		1, 0, 0, 0, 834, 832, 1, 0, 0, 0, 835, 837, 3, 12, 6, 0, 836, 835, 1, 0,
		0, 0, 836, 837, 1, 0, 0, 0, 837, 838, 1, 0, 0, 0, 838, 840, 5, 21, 0, 0,
		839, 836, 1, 0, 0, 0, 840, 843, 1, 0, 0, 0, 841, 839, 1, 0, 0, 0, 841,
		842, 1, 0, 0, 0, 842, 844, 1, 0, 0, 0, 843, 841, 1, 0, 0, 0, 844, 852,
		3, 54, 27, 0, 845, 848, 5, 21, 0, 0, 846, 849, 3, 54, 27, 0, 847, 849,
		3, 12, 6, 0, 848, 846, 1, 0, 0, 0, 848, 847, 1, 0, 0, 0, 848, 849, 1, 0,
		0, 0, 849, 851, 1, 0, 0, 0, 850, 845, 1, 0, 0, 0, 851, 854, 1, 0, 0, 0,
		852, 850, 1, 0, 0, 0, 852, 853, 1, 0, 0, 0, 853, 103, 1, 0, 0, 0, 854,
		852, 1, 0, 0, 0, 855, 857, 3, 12, 6, 0, 856, 855, 1, 0, 0, 0, 856, 857,
		1, 0, 0, 0, 857, 858, 1, 0, 0, 0, 858, 860, 5, 21, 0, 0, 859, 856, 1, 0,
		0, 0, 860, 863, 1, 0, 0, 0, 861, 859, 1, 0, 0, 0, 861, 862, 1, 0, 0, 0,
		862, 864, 1, 0, 0, 0, 863, 861, 1, 0, 0, 0, 864, 872, 3, 52, 26, 0, 865,
		868, 5, 21, 0, 0, 866, 869, 3, 52, 26, 0, 867, 869, 3, 12, 6, 0, 868, 866,
		1, 0, 0, 0, 868, 867, 1, 0, 0, 0, 868, 869, 1, 0, 0, 0, 869, 871, 1, 0,
		0, 0, 870, 865, 1, 0, 0, 0, 871, 874, 1, 0, 0, 0, 872, 870, 1, 0, 0, 0,
		872, 873, 1, 0, 0, 0, 873, 105, 1, 0, 0, 0, 874, 872, 1, 0, 0, 0, 875,
		877, 3, 12, 6, 0, 876, 875, 1, 0, 0, 0, 876, 877, 1, 0, 0, 0, 877, 878,
		1, 0, 0, 0, 878, 880, 5, 21, 0, 0, 879, 876, 1, 0, 0, 0, 880, 881, 1, 0,
		0, 0, 881, 879, 1, 0, 0, 0, 881, 882, 1, 0, 0, 0, 882, 884, 1, 0, 0, 0,
		883, 885, 3, 12, 6, 0, 884, 883, 1, 0, 0, 0, 884, 885, 1, 0, 0, 0, 885,
		107, 1, 0, 0, 0, 886, 891, 3, 28, 14, 0, 887, 888, 5, 23, 0, 0, 888, 890,
		3, 28, 14, 0, 889, 887, 1, 0, 0, 0, 890, 893, 1, 0, 0, 0, 891, 889, 1,
		0, 0, 0, 891, 892, 1, 0, 0, 0, 892, 109, 1, 0, 0, 0, 893, 891, 1, 0, 0,
		0, 894, 899, 3, 16, 8, 0, 895, 896, 5, 23, 0, 0, 896, 898, 3, 16, 8, 0,
		897, 895, 1, 0, 0, 0, 898, 901, 1, 0, 0, 0, 899, 897, 1, 0, 0, 0, 899,
		900, 1, 0, 0, 0, 900, 111, 1, 0, 0, 0, 901, 899, 1, 0, 0, 0, 902, 903,
		5, 29, 0, 0, 903, 904, 5, 31, 0, 0, 904, 905, 3, 114, 57, 0, 905, 906,
		5, 31, 0, 0, 906, 907, 3, 116, 58, 0, 907, 908, 5, 31, 0, 0, 908, 909,
		3, 122, 61, 0, 909, 910, 5, 31, 0, 0, 910, 911, 5, 29, 0, 0, 911, 113,
		1, 0, 0, 0, 912, 913, 3, 118, 59, 0, 913, 115, 1, 0, 0, 0, 914, 915, 3,
		118, 59, 0, 915, 117, 1, 0, 0, 0, 916, 918, 3, 120, 60, 0, 917, 916, 1,
		0, 0, 0, 918, 919, 1, 0, 0, 0, 919, 917, 1, 0, 0, 0, 919, 920, 1, 0, 0,
		0, 920, 119, 1, 0, 0, 0, 921, 941, 3, 132, 66, 0, 922, 941, 5, 10, 0, 0,
		923, 941, 5, 12, 0, 0, 924, 941, 5, 13, 0, 0, 925, 941, 5, 14, 0, 0, 926,
		941, 5, 15, 0, 0, 927, 941, 5, 16, 0, 0, 928, 941, 5, 19, 0, 0, 929, 941,
		5, 20, 0, 0, 930, 941, 5, 22, 0, 0, 931, 941, 5, 25, 0, 0, 932, 941, 5,
		34, 0, 0, 933, 941, 5, 36, 0, 0, 934, 941, 5, 37, 0, 0, 935, 941, 5, 38,
		0, 0, 936, 941, 5, 39, 0, 0, 937, 941, 5, 40, 0, 0, 938, 941, 5, 41, 0,
		0, 939, 941, 5, 42, 0, 0, 940, 921, 1, 0, 0, 0, 940, 922, 1, 0, 0, 0, 940,
		923, 1, 0, 0, 0, 940, 924, 1, 0, 0, 0, 940, 925, 1, 0, 0, 0, 940, 926,
		1, 0, 0, 0, 940, 927, 1, 0, 0, 0, 940, 928, 1, 0, 0, 0, 940, 929, 1, 0,
		0, 0, 940, 930, 1, 0, 0, 0, 940, 931, 1, 0, 0, 0, 940, 932, 1, 0, 0, 0,
		940, 933, 1, 0, 0, 0, 940, 934, 1, 0, 0, 0, 940, 935, 1, 0, 0, 0, 940,
		936, 1, 0, 0, 0, 940, 937, 1, 0, 0, 0, 940, 938, 1, 0, 0, 0, 940, 939,
		1, 0, 0, 0, 941, 121, 1, 0, 0, 0, 942, 944, 3, 124, 62, 0, 943, 942, 1,
		0, 0, 0, 944, 945, 1, 0, 0, 0, 945, 943, 1, 0, 0, 0, 945, 946, 1, 0, 0,
		0, 946, 123, 1, 0, 0, 0, 947, 981, 3, 132, 66, 0, 948, 981, 5, 10, 0, 0,
		949, 981, 5, 11, 0, 0, 950, 981, 5, 12, 0, 0, 951, 981, 5, 13, 0, 0, 952,
		981, 5, 14, 0, 0, 953, 981, 5, 15, 0, 0, 954, 981, 5, 16, 0, 0, 955, 981,
		5, 17, 0, 0, 956, 981, 5, 18, 0, 0, 957, 981, 5, 19, 0, 0, 958, 981, 5,
		20, 0, 0, 959, 981, 5, 21, 0, 0, 960, 981, 5, 22, 0, 0, 961, 981, 5, 23,
		0, 0, 962, 981, 5, 24, 0, 0, 963, 981, 5, 25, 0, 0, 964, 981, 5, 26, 0,
		0, 965, 981, 5, 27, 0, 0, 966, 981, 5, 28, 0, 0, 967, 981, 5, 29, 0, 0,
		968, 981, 5, 30, 0, 0, 969, 981, 5, 32, 0, 0, 970, 981, 5, 33, 0, 0, 971,
		981, 5, 34, 0, 0, 972, 981, 5, 35, 0, 0, 973, 981, 5, 36, 0, 0, 974, 981,
		5, 37, 0, 0, 975, 981, 5, 38, 0, 0, 976, 981, 5, 39, 0, 0, 977, 981, 5,
		40, 0, 0, 978, 981, 5, 41, 0, 0, 979, 981, 5, 42, 0, 0, 980, 947, 1, 0,
		0, 0, 980, 948, 1, 0, 0, 0, 980, 949, 1, 0, 0, 0, 980, 950, 1, 0, 0, 0,
		980, 951, 1, 0, 0, 0, 980, 952, 1, 0, 0, 0, 980, 953, 1, 0, 0, 0, 980,
		954, 1, 0, 0, 0, 980, 955, 1, 0, 0, 0, 980, 956, 1, 0, 0, 0, 980, 957,
		1, 0, 0, 0, 980, 958, 1, 0, 0, 0, 980, 959, 1, 0, 0, 0, 980, 960, 1, 0,
		0, 0, 980, 961, 1, 0, 0, 0, 980, 962, 1, 0, 0, 0, 980, 963, 1, 0, 0, 0,
		980, 964, 1, 0, 0, 0, 980, 965, 1, 0, 0, 0, 980, 966, 1, 0, 0, 0, 980,
		967, 1, 0, 0, 0, 980, 968, 1, 0, 0, 0, 980, 969, 1, 0, 0, 0, 980, 970,
		1, 0, 0, 0, 980, 971, 1, 0, 0, 0, 980, 972, 1, 0, 0, 0, 980, 973, 1, 0,
		0, 0, 980, 974, 1, 0, 0, 0, 980, 975, 1, 0, 0, 0, 980, 976, 1, 0, 0, 0,
		980, 977, 1, 0, 0, 0, 980, 978, 1, 0, 0, 0, 980, 979, 1, 0, 0, 0, 981,
		125, 1, 0, 0, 0, 982, 983, 5, 7, 0, 0, 983, 984, 5, 4, 0, 0, 984, 127,
		1, 0, 0, 0, 985, 986, 7, 4, 0, 0, 986, 129, 1, 0, 0, 0, 987, 1023, 3, 132,
		66, 0, 988, 1023, 5, 10, 0, 0, 989, 1023, 5, 11, 0, 0, 990, 1023, 5, 12,
		0, 0, 991, 1023, 5, 13, 0, 0, 992, 1023, 5, 14, 0, 0, 993, 1023, 5, 15,
		0, 0, 994, 1023, 5, 16, 0, 0, 995, 1023, 5, 17, 0, 0, 996, 1023, 5, 18,
		0, 0, 997, 1023, 5, 19, 0, 0, 998, 1023, 5, 20, 0, 0, 999, 1023, 5, 21,
		0, 0, 1000, 1023, 5, 22, 0, 0, 1001, 1023, 5, 23, 0, 0, 1002, 1023, 5,
		24, 0, 0, 1003, 1023, 5, 25, 0, 0, 1004, 1023, 5, 26, 0, 0, 1005, 1023,
		5, 27, 0, 0, 1006, 1023, 5, 28, 0, 0, 1007, 1023, 5, 29, 0, 0, 1008, 1023,
		5, 30, 0, 0, 1009, 1023, 5, 31, 0, 0, 1010, 1023, 5, 32, 0, 0, 1011, 1023,
		5, 33, 0, 0, 1012, 1023, 5, 34, 0, 0, 1013, 1023, 5, 35, 0, 0, 1014, 1023,
		5, 36, 0, 0, 1015, 1023, 5, 37, 0, 0, 1016, 1023, 5, 38, 0, 0, 1017, 1023,
		5, 39, 0, 0, 1018, 1023, 5, 40, 0, 0, 1019, 1023, 5, 41, 0, 0, 1020, 1023,
		5, 42, 0, 0, 1021, 1023, 5, 44, 0, 0, 1022, 987, 1, 0, 0, 0, 1022, 988,
		1, 0, 0, 0, 1022, 989, 1, 0, 0, 0, 1022, 990, 1, 0, 0, 0, 1022, 991, 1,
		0, 0, 0, 1022, 992, 1, 0, 0, 0, 1022, 993, 1, 0, 0, 0, 1022, 994, 1, 0,
		0, 0, 1022, 995, 1, 0, 0, 0, 1022, 996, 1, 0, 0, 0, 1022, 997, 1, 0, 0,
		0, 1022, 998, 1, 0, 0, 0, 1022, 999, 1, 0, 0, 0, 1022, 1000, 1, 0, 0, 0,
		1022, 1001, 1, 0, 0, 0, 1022, 1002, 1, 0, 0, 0, 1022, 1003, 1, 0, 0, 0,
		1022, 1004, 1, 0, 0, 0, 1022, 1005, 1, 0, 0, 0, 1022, 1006, 1, 0, 0, 0,
		1022, 1007, 1, 0, 0, 0, 1022, 1008, 1, 0, 0, 0, 1022, 1009, 1, 0, 0, 0,
		1022, 1010, 1, 0, 0, 0, 1022, 1011, 1, 0, 0, 0, 1022, 1012, 1, 0, 0, 0,
		1022, 1013, 1, 0, 0, 0, 1022, 1014, 1, 0, 0, 0, 1022, 1015, 1, 0, 0, 0,
		1022, 1016, 1, 0, 0, 0, 1022, 1017, 1, 0, 0, 0, 1022, 1018, 1, 0, 0, 0,
		1022, 1019, 1, 0, 0, 0, 1022, 1020, 1, 0, 0, 0, 1022, 1021, 1, 0, 0, 0,
		1023, 131, 1, 0, 0, 0, 1024, 1025, 7, 5, 0, 0, 1025, 133, 1, 0, 0, 0, 134,
		136, 141, 146, 150, 155, 158, 193, 198, 202, 207, 211, 216, 221, 224, 227,
		251, 256, 261, 267, 271, 275, 311, 315, 318, 323, 329, 334, 338, 342, 345,
		349, 352, 356, 358, 363, 373, 376, 379, 384, 388, 392, 394, 417, 420, 424,
		428, 432, 435, 437, 475, 485, 490, 492, 495, 499, 502, 506, 508, 513, 518,
		520, 525, 530, 532, 535, 546, 550, 554, 557, 562, 566, 570, 573, 576, 581,
		584, 587, 590, 597, 603, 605, 608, 615, 619, 626, 634, 639, 646, 649, 653,
		656, 660, 663, 668, 671, 675, 678, 682, 685, 689, 691, 695, 700, 704, 740,
		753, 758, 764, 798, 801, 808, 815, 817, 824, 828, 832, 836, 841, 848, 852,
		856, 861, 868, 872, 876, 881, 884, 891, 899, 919, 940, 945, 980, 1022,
	}
	deserializer := antlr.NewATNDeserializer(nil)
	staticData.atn = deserializer.Deserialize(staticData.serializedATN)
	atn := staticData.atn
	staticData.decisionToDFA = make([]*antlr.DFA, len(atn.DecisionToState))
	decisionToDFA := staticData.decisionToDFA
	for index, state := range atn.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(state, index)
	}
}

// RFC5322ParserInit initializes any static state used to implement RFC5322Parser. By default the
// static state used to implement the parser is lazily initialized during the first call to
// NewRFC5322Parser(). You can call this function if you wish to initialize the static state ahead
// of time.
func RFC5322ParserInit() {
	staticData := &rfc5322parserParserStaticData
	staticData.once.Do(rfc5322parserParserInit)
}

// NewRFC5322Parser produces a new parser instance for the optional input antlr.TokenStream.
func NewRFC5322Parser(input antlr.TokenStream) *RFC5322Parser {
	RFC5322ParserInit()
	this := new(RFC5322Parser)
	this.BaseParser = antlr.NewBaseParser(input)
	staticData := &rfc5322parserParserStaticData
	this.Interpreter = antlr.NewParserATNSimulator(this, staticData.atn, staticData.decisionToDFA, staticData.predictionContextCache)
	this.RuleNames = staticData.ruleNames
	this.LiteralNames = staticData.literalNames
	this.SymbolicNames = staticData.symbolicNames
	this.GrammarFileName = "RFC5322Parser.g4"

	return this
}

// RFC5322Parser tokens.
const (
	RFC5322ParserEOF          = antlr.TokenEOF
	RFC5322ParserU_00         = 1
	RFC5322ParserU_01_08      = 2
	RFC5322ParserTAB          = 3
	RFC5322ParserLF           = 4
	RFC5322ParserU_0B         = 5
	RFC5322ParserU_0C         = 6
	RFC5322ParserCR           = 7
	RFC5322ParserU_0E_1F      = 8
	RFC5322ParserSP           = 9
	RFC5322ParserExclamation  = 10
	RFC5322ParserDQuote       = 11
	RFC5322ParserHash         = 12
	RFC5322ParserDollar       = 13
	RFC5322ParserPercent      = 14
	RFC5322ParserAmpersand    = 15
	RFC5322ParserSQuote       = 16
	RFC5322ParserLParens      = 17
	RFC5322ParserRParens      = 18
	RFC5322ParserAsterisk     = 19
	RFC5322ParserPlus         = 20
	RFC5322ParserComma        = 21
	RFC5322ParserMinus        = 22
	RFC5322ParserPeriod       = 23
	RFC5322ParserSlash        = 24
	RFC5322ParserDigit        = 25
	RFC5322ParserColon        = 26
	RFC5322ParserSemicolon    = 27
	RFC5322ParserLess         = 28
	RFC5322ParserEqual        = 29
	RFC5322ParserGreater      = 30
	RFC5322ParserQuestion     = 31
	RFC5322ParserAt           = 32
	RFC5322ParserLBracket     = 33
	RFC5322ParserBackslash    = 34
	RFC5322ParserRBracket     = 35
	RFC5322ParserCaret        = 36
	RFC5322ParserUnderscore   = 37
	RFC5322ParserBacktick     = 38
	RFC5322ParserLCurly       = 39
	RFC5322ParserPipe         = 40
	RFC5322ParserRCurly       = 41
	RFC5322ParserTilde        = 42
	RFC5322ParserDelete       = 43
	RFC5322ParserUTF8NonAscii = 44
	RFC5322ParserA            = 45
	RFC5322ParserB            = 46
	RFC5322ParserC            = 47
	RFC5322ParserD            = 48
	RFC5322ParserE            = 49
	RFC5322ParserF            = 50
	RFC5322ParserG            = 51
	RFC5322ParserH            = 52
	RFC5322ParserI            = 53
	RFC5322ParserJ            = 54
	RFC5322ParserK            = 55
	RFC5322ParserL            = 56
	RFC5322ParserM            = 57
	RFC5322ParserN            = 58
	RFC5322ParserO            = 59
	RFC5322ParserP            = 60
	RFC5322ParserQ            = 61
	RFC5322ParserR            = 62
	RFC5322ParserS            = 63
	RFC5322ParserT            = 64
	RFC5322ParserU            = 65
	RFC5322ParserV            = 66
	RFC5322ParserW            = 67
	RFC5322ParserX            = 68
	RFC5322ParserY            = 69
	RFC5322ParserZ            = 70
)

// RFC5322Parser rules.
const (
	RFC5322ParserRULE_quotedChar    = 0
	RFC5322ParserRULE_quotedPair    = 1
	RFC5322ParserRULE_fws           = 2
	RFC5322ParserRULE_ctext         = 3
	RFC5322ParserRULE_ccontent      = 4
	RFC5322ParserRULE_comment       = 5
	RFC5322ParserRULE_cfws          = 6
	RFC5322ParserRULE_atext         = 7
	RFC5322ParserRULE_atom          = 8
	RFC5322ParserRULE_dotAtom       = 9
	RFC5322ParserRULE_qtext         = 10
	RFC5322ParserRULE_quotedContent = 11
	RFC5322ParserRULE_quotedValue   = 12
	RFC5322ParserRULE_quotedString  = 13
	RFC5322ParserRULE_word          = 14
	RFC5322ParserRULE_dateTime      = 15
	RFC5322ParserRULE_dayOfweek     = 16
	RFC5322ParserRULE_dayName       = 17
	RFC5322ParserRULE_day           = 18
	RFC5322ParserRULE_month         = 19
	RFC5322ParserRULE_year          = 20
	RFC5322ParserRULE_hour          = 21
	RFC5322ParserRULE_minute        = 22
	RFC5322ParserRULE_second        = 23
	RFC5322ParserRULE_offset        = 24
	RFC5322ParserRULE_zone          = 25
	RFC5322ParserRULE_address       = 26
	RFC5322ParserRULE_mailbox       = 27
	RFC5322ParserRULE_nameAddr      = 28
	RFC5322ParserRULE_angleAddr     = 29
	RFC5322ParserRULE_group         = 30
	RFC5322ParserRULE_unspaced      = 31
	RFC5322ParserRULE_displayName   = 32
	RFC5322ParserRULE_mailboxList   = 33
	RFC5322ParserRULE_addressList   = 34
	RFC5322ParserRULE_groupList     = 35
	RFC5322ParserRULE_addrSpec      = 36
	RFC5322ParserRULE_localPart     = 37
	RFC5322ParserRULE_port          = 38
	RFC5322ParserRULE_domain        = 39
	RFC5322ParserRULE_domainLiteral = 40
	RFC5322ParserRULE_dtext         = 41
	RFC5322ParserRULE_obsNoWSCTL    = 42
	RFC5322ParserRULE_obsCtext      = 43
	RFC5322ParserRULE_obsQtext      = 44
	RFC5322ParserRULE_obsQP         = 45
	RFC5322ParserRULE_obsFWS        = 46
	RFC5322ParserRULE_obsZone       = 47
	RFC5322ParserRULE_obsAngleAddr  = 48
	RFC5322ParserRULE_obsRoute      = 49
	RFC5322ParserRULE_obsDomainList = 50
	RFC5322ParserRULE_obsMboxList   = 51
	RFC5322ParserRULE_obsAddrList   = 52
	RFC5322ParserRULE_obsGroupList  = 53
	RFC5322ParserRULE_obsLocalPart  = 54
	RFC5322ParserRULE_obsDomain     = 55
	RFC5322ParserRULE_encodedWord   = 56
	RFC5322ParserRULE_charset       = 57
	RFC5322ParserRULE_encoding      = 58
	RFC5322ParserRULE_token         = 59
	RFC5322ParserRULE_tokenChar     = 60
	RFC5322ParserRULE_encodedText   = 61
	RFC5322ParserRULE_encodedChar   = 62
	RFC5322ParserRULE_crlf          = 63
	RFC5322ParserRULE_wsp           = 64
	RFC5322ParserRULE_vchar         = 65
	RFC5322ParserRULE_alpha         = 66
)

// IQuotedCharContext is an interface to support dynamic dispatch.
type IQuotedCharContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQuotedCharContext differentiates from other interfaces.
	IsQuotedCharContext()
}

type QuotedCharContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQuotedCharContext() *QuotedCharContext {
	var p = new(QuotedCharContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFC5322ParserRULE_quotedChar
	return p
}

func (*QuotedCharContext) IsQuotedCharContext() {}

func NewQuotedCharContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QuotedCharContext {
	var p = new(QuotedCharContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC5322ParserRULE_quotedChar

	return p
}

func (s *QuotedCharContext) GetParser() antlr.Parser { return s.parser }

func (s *QuotedCharContext) Vchar() IVcharContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVcharContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVcharContext)
}

func (s *QuotedCharContext) Wsp() IWspContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWspContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWspContext)
}

func (s *QuotedCharContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QuotedCharContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QuotedCharContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.EnterQuotedChar(s)
	}
}

func (s *QuotedCharContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.ExitQuotedChar(s)
	}
}

func (p *RFC5322Parser) QuotedChar() (localctx IQuotedCharContext) {
	this := p
	_ = this

	localctx = NewQuotedCharContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, RFC5322ParserRULE_quotedChar)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(136)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case RFC5322ParserExclamation, RFC5322ParserDQuote, RFC5322ParserHash, RFC5322ParserDollar, RFC5322ParserPercent, RFC5322ParserAmpersand, RFC5322ParserSQuote, RFC5322ParserLParens, RFC5322ParserRParens, RFC5322ParserAsterisk, RFC5322ParserPlus, RFC5322ParserComma, RFC5322ParserMinus, RFC5322ParserPeriod, RFC5322ParserSlash, RFC5322ParserDigit, RFC5322ParserColon, RFC5322ParserSemicolon, RFC5322ParserLess, RFC5322ParserEqual, RFC5322ParserGreater, RFC5322ParserQuestion, RFC5322ParserAt, RFC5322ParserLBracket, RFC5322ParserBackslash, RFC5322ParserRBracket, RFC5322ParserCaret, RFC5322ParserUnderscore, RFC5322ParserBacktick, RFC5322ParserLCurly, RFC5322ParserPipe, RFC5322ParserRCurly, RFC5322ParserTilde, RFC5322ParserUTF8NonAscii, RFC5322ParserA, RFC5322ParserB, RFC5322ParserC, RFC5322ParserD, RFC5322ParserE, RFC5322ParserF, RFC5322ParserG, RFC5322ParserH, RFC5322ParserI, RFC5322ParserJ, RFC5322ParserK, RFC5322ParserL, RFC5322ParserM, RFC5322ParserN, RFC5322ParserO, RFC5322ParserP, RFC5322ParserQ, RFC5322ParserR, RFC5322ParserS, RFC5322ParserT, RFC5322ParserU, RFC5322ParserV, RFC5322ParserW, RFC5322ParserX, RFC5322ParserY, RFC5322ParserZ:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(134)
			p.Vchar()
		}

	case RFC5322ParserTAB, RFC5322ParserSP:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(135)
			p.Wsp()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IQuotedPairContext is an interface to support dynamic dispatch.
type IQuotedPairContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQuotedPairContext differentiates from other interfaces.
	IsQuotedPairContext()
}

type QuotedPairContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQuotedPairContext() *QuotedPairContext {
	var p = new(QuotedPairContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFC5322ParserRULE_quotedPair
	return p
}

func (*QuotedPairContext) IsQuotedPairContext() {}

func NewQuotedPairContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QuotedPairContext {
	var p = new(QuotedPairContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC5322ParserRULE_quotedPair

	return p
}

func (s *QuotedPairContext) GetParser() antlr.Parser { return s.parser }

func (s *QuotedPairContext) Backslash() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserBackslash, 0)
}

func (s *QuotedPairContext) QuotedChar() IQuotedCharContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQuotedCharContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQuotedCharContext)
}

func (s *QuotedPairContext) ObsQP() IObsQPContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObsQPContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObsQPContext)
}

func (s *QuotedPairContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QuotedPairContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QuotedPairContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.EnterQuotedPair(s)
	}
}

func (s *QuotedPairContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.ExitQuotedPair(s)
	}
}

func (p *RFC5322Parser) QuotedPair() (localctx IQuotedPairContext) {
	this := p
	_ = this

	localctx = NewQuotedPairContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, RFC5322ParserRULE_quotedPair)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(141)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 1, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(138)
			p.Match(RFC5322ParserBackslash)
		}
		{
			p.SetState(139)
			p.QuotedChar()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(140)
			p.ObsQP()
		}

	}

	return localctx
}

// IFwsContext is an interface to support dynamic dispatch.
type IFwsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFwsContext differentiates from other interfaces.
	IsFwsContext()
}

type FwsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFwsContext() *FwsContext {
	var p = new(FwsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFC5322ParserRULE_fws
	return p
}

func (*FwsContext) IsFwsContext() {}

func NewFwsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FwsContext {
	var p = new(FwsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC5322ParserRULE_fws

	return p
}

func (s *FwsContext) GetParser() antlr.Parser { return s.parser }

func (s *FwsContext) Crlf() ICrlfContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICrlfContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICrlfContext)
}

func (s *FwsContext) AllWsp() []IWspContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IWspContext); ok {
			len++
		}
	}

	tst := make([]IWspContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IWspContext); ok {
			tst[i] = t.(IWspContext)
			i++
		}
	}

	return tst
}

func (s *FwsContext) Wsp(i int) IWspContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWspContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWspContext)
}

func (s *FwsContext) ObsFWS() IObsFWSContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObsFWSContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObsFWSContext)
}

func (s *FwsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FwsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FwsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.EnterFws(s)
	}
}

func (s *FwsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.ExitFws(s)
	}
}

func (p *RFC5322Parser) Fws() (localctx IFwsContext) {
	this := p
	_ = this

	localctx = NewFwsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, RFC5322ParserRULE_fws)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(158)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 5, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(150)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 3, p.GetParserRuleContext()) == 1 {
			p.SetState(146)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == RFC5322ParserTAB || _la == RFC5322ParserSP {
				{
					p.SetState(143)
					p.Wsp()
				}

				p.SetState(148)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(149)
				p.Crlf()
			}

		}
		p.SetState(153)
		p.GetErrorHandler().Sync(p)
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(152)
					p.Wsp()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(155)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 4, p.GetParserRuleContext())
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(157)
			p.ObsFWS()
		}

	}

	return localctx
}

// ICtextContext is an interface to support dynamic dispatch.
type ICtextContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCtextContext differentiates from other interfaces.
	IsCtextContext()
}

type CtextContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCtextContext() *CtextContext {
	var p = new(CtextContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFC5322ParserRULE_ctext
	return p
}

func (*CtextContext) IsCtextContext() {}

func NewCtextContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CtextContext {
	var p = new(CtextContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC5322ParserRULE_ctext

	return p
}

func (s *CtextContext) GetParser() antlr.Parser { return s.parser }

func (s *CtextContext) Alpha() IAlphaContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlphaContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlphaContext)
}

func (s *CtextContext) Exclamation() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserExclamation, 0)
}

func (s *CtextContext) DQuote() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserDQuote, 0)
}

func (s *CtextContext) Hash() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserHash, 0)
}

func (s *CtextContext) Dollar() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserDollar, 0)
}

func (s *CtextContext) Percent() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserPercent, 0)
}

func (s *CtextContext) Ampersand() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserAmpersand, 0)
}

func (s *CtextContext) SQuote() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserSQuote, 0)
}

func (s *CtextContext) Asterisk() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserAsterisk, 0)
}

func (s *CtextContext) Plus() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserPlus, 0)
}

func (s *CtextContext) Comma() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserComma, 0)
}

func (s *CtextContext) Minus() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserMinus, 0)
}

func (s *CtextContext) Period() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserPeriod, 0)
}

func (s *CtextContext) Slash() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserSlash, 0)
}

func (s *CtextContext) Digit() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserDigit, 0)
}

func (s *CtextContext) Colon() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserColon, 0)
}

func (s *CtextContext) Semicolon() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserSemicolon, 0)
}

func (s *CtextContext) Less() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserLess, 0)
}

func (s *CtextContext) Equal() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserEqual, 0)
}

func (s *CtextContext) Greater() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserGreater, 0)
}

func (s *CtextContext) Question() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserQuestion, 0)
}

func (s *CtextContext) At() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserAt, 0)
}

func (s *CtextContext) LBracket() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserLBracket, 0)
}

func (s *CtextContext) RBracket() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserRBracket, 0)
}

func (s *CtextContext) Caret() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserCaret, 0)
}

func (s *CtextContext) Underscore() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserUnderscore, 0)
}

func (s *CtextContext) Backtick() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserBacktick, 0)
}

func (s *CtextContext) LCurly() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserLCurly, 0)
}

func (s *CtextContext) Pipe() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserPipe, 0)
}

func (s *CtextContext) RCurly() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserRCurly, 0)
}

func (s *CtextContext) Tilde() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserTilde, 0)
}

func (s *CtextContext) ObsCtext() IObsCtextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObsCtextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObsCtextContext)
}

func (s *CtextContext) UTF8NonAscii() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserUTF8NonAscii, 0)
}

func (s *CtextContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CtextContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CtextContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.EnterCtext(s)
	}
}

func (s *CtextContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.ExitCtext(s)
	}
}

func (p *RFC5322Parser) Ctext() (localctx ICtextContext) {
	this := p
	_ = this

	localctx = NewCtextContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, RFC5322ParserRULE_ctext)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(193)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case RFC5322ParserA, RFC5322ParserB, RFC5322ParserC, RFC5322ParserD, RFC5322ParserE, RFC5322ParserF, RFC5322ParserG, RFC5322ParserH, RFC5322ParserI, RFC5322ParserJ, RFC5322ParserK, RFC5322ParserL, RFC5322ParserM, RFC5322ParserN, RFC5322ParserO, RFC5322ParserP, RFC5322ParserQ, RFC5322ParserR, RFC5322ParserS, RFC5322ParserT, RFC5322ParserU, RFC5322ParserV, RFC5322ParserW, RFC5322ParserX, RFC5322ParserY, RFC5322ParserZ:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(160)
			p.Alpha()
		}

	case RFC5322ParserExclamation:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(161)
			p.Match(RFC5322ParserExclamation)
		}

	case RFC5322ParserDQuote:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(162)
			p.Match(RFC5322ParserDQuote)
		}

	case RFC5322ParserHash:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(163)
			p.Match(RFC5322ParserHash)
		}

	case RFC5322ParserDollar:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(164)
			p.Match(RFC5322ParserDollar)
		}

	case RFC5322ParserPercent:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(165)
			p.Match(RFC5322ParserPercent)
		}

	case RFC5322ParserAmpersand:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(166)
			p.Match(RFC5322ParserAmpersand)
		}

	case RFC5322ParserSQuote:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(167)
			p.Match(RFC5322ParserSQuote)
		}

	case RFC5322ParserAsterisk:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(168)
			p.Match(RFC5322ParserAsterisk)
		}

	case RFC5322ParserPlus:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(169)
			p.Match(RFC5322ParserPlus)
		}

	case RFC5322ParserComma:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(170)
			p.Match(RFC5322ParserComma)
		}

	case RFC5322ParserMinus:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(171)
			p.Match(RFC5322ParserMinus)
		}

	case RFC5322ParserPeriod:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(172)
			p.Match(RFC5322ParserPeriod)
		}

	case RFC5322ParserSlash:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(173)
			p.Match(RFC5322ParserSlash)
		}

	case RFC5322ParserDigit:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(174)
			p.Match(RFC5322ParserDigit)
		}

	case RFC5322ParserColon:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(175)
			p.Match(RFC5322ParserColon)
		}

	case RFC5322ParserSemicolon:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(176)
			p.Match(RFC5322ParserSemicolon)
		}

	case RFC5322ParserLess:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(177)
			p.Match(RFC5322ParserLess)
		}

	case RFC5322ParserEqual:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(178)
			p.Match(RFC5322ParserEqual)
		}

	case RFC5322ParserGreater:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(179)
			p.Match(RFC5322ParserGreater)
		}

	case RFC5322ParserQuestion:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(180)
			p.Match(RFC5322ParserQuestion)
		}

	case RFC5322ParserAt:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(181)
			p.Match(RFC5322ParserAt)
		}

	case RFC5322ParserLBracket:
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(182)
			p.Match(RFC5322ParserLBracket)
		}

	case RFC5322ParserRBracket:
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(183)
			p.Match(RFC5322ParserRBracket)
		}

	case RFC5322ParserCaret:
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(184)
			p.Match(RFC5322ParserCaret)
		}

	case RFC5322ParserUnderscore:
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(185)
			p.Match(RFC5322ParserUnderscore)
		}

	case RFC5322ParserBacktick:
		p.EnterOuterAlt(localctx, 27)
		{
			p.SetState(186)
			p.Match(RFC5322ParserBacktick)
		}

	case RFC5322ParserLCurly:
		p.EnterOuterAlt(localctx, 28)
		{
			p.SetState(187)
			p.Match(RFC5322ParserLCurly)
		}

	case RFC5322ParserPipe:
		p.EnterOuterAlt(localctx, 29)
		{
			p.SetState(188)
			p.Match(RFC5322ParserPipe)
		}

	case RFC5322ParserRCurly:
		p.EnterOuterAlt(localctx, 30)
		{
			p.SetState(189)
			p.Match(RFC5322ParserRCurly)
		}

	case RFC5322ParserTilde:
		p.EnterOuterAlt(localctx, 31)
		{
			p.SetState(190)
			p.Match(RFC5322ParserTilde)
		}

	case RFC5322ParserU_01_08, RFC5322ParserU_0B, RFC5322ParserU_0C, RFC5322ParserU_0E_1F, RFC5322ParserDelete:
		p.EnterOuterAlt(localctx, 32)
		{
			p.SetState(191)
			p.ObsCtext()
		}

	case RFC5322ParserUTF8NonAscii:
		p.EnterOuterAlt(localctx, 33)
		{
			p.SetState(192)
			p.Match(RFC5322ParserUTF8NonAscii)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ICcontentContext is an interface to support dynamic dispatch.
type ICcontentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCcontentContext differentiates from other interfaces.
	IsCcontentContext()
}

type CcontentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCcontentContext() *CcontentContext {
	var p = new(CcontentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFC5322ParserRULE_ccontent
	return p
}

func (*CcontentContext) IsCcontentContext() {}

func NewCcontentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CcontentContext {
	var p = new(CcontentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC5322ParserRULE_ccontent

	return p
}

func (s *CcontentContext) GetParser() antlr.Parser { return s.parser }

func (s *CcontentContext) Ctext() ICtextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICtextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICtextContext)
}

func (s *CcontentContext) QuotedPair() IQuotedPairContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQuotedPairContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQuotedPairContext)
}

func (s *CcontentContext) Comment() ICommentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommentContext)
}

func (s *CcontentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CcontentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CcontentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.EnterCcontent(s)
	}
}

func (s *CcontentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.ExitCcontent(s)
	}
}

func (p *RFC5322Parser) Ccontent() (localctx ICcontentContext) {
	this := p
	_ = this

	localctx = NewCcontentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, RFC5322ParserRULE_ccontent)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(198)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case RFC5322ParserU_01_08, RFC5322ParserU_0B, RFC5322ParserU_0C, RFC5322ParserU_0E_1F, RFC5322ParserExclamation, RFC5322ParserDQuote, RFC5322ParserHash, RFC5322ParserDollar, RFC5322ParserPercent, RFC5322ParserAmpersand, RFC5322ParserSQuote, RFC5322ParserAsterisk, RFC5322ParserPlus, RFC5322ParserComma, RFC5322ParserMinus, RFC5322ParserPeriod, RFC5322ParserSlash, RFC5322ParserDigit, RFC5322ParserColon, RFC5322ParserSemicolon, RFC5322ParserLess, RFC5322ParserEqual, RFC5322ParserGreater, RFC5322ParserQuestion, RFC5322ParserAt, RFC5322ParserLBracket, RFC5322ParserRBracket, RFC5322ParserCaret, RFC5322ParserUnderscore, RFC5322ParserBacktick, RFC5322ParserLCurly, RFC5322ParserPipe, RFC5322ParserRCurly, RFC5322ParserTilde, RFC5322ParserDelete, RFC5322ParserUTF8NonAscii, RFC5322ParserA, RFC5322ParserB, RFC5322ParserC, RFC5322ParserD, RFC5322ParserE, RFC5322ParserF, RFC5322ParserG, RFC5322ParserH, RFC5322ParserI, RFC5322ParserJ, RFC5322ParserK, RFC5322ParserL, RFC5322ParserM, RFC5322ParserN, RFC5322ParserO, RFC5322ParserP, RFC5322ParserQ, RFC5322ParserR, RFC5322ParserS, RFC5322ParserT, RFC5322ParserU, RFC5322ParserV, RFC5322ParserW, RFC5322ParserX, RFC5322ParserY, RFC5322ParserZ:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(195)
			p.Ctext()
		}

	case RFC5322ParserBackslash:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(196)
			p.QuotedPair()
		}

	case RFC5322ParserLParens:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(197)
			p.Comment()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ICommentContext is an interface to support dynamic dispatch.
type ICommentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCommentContext differentiates from other interfaces.
	IsCommentContext()
}

type CommentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCommentContext() *CommentContext {
	var p = new(CommentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFC5322ParserRULE_comment
	return p
}

func (*CommentContext) IsCommentContext() {}

func NewCommentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CommentContext {
	var p = new(CommentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC5322ParserRULE_comment

	return p
}

func (s *CommentContext) GetParser() antlr.Parser { return s.parser }

func (s *CommentContext) LParens() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserLParens, 0)
}

func (s *CommentContext) RParens() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserRParens, 0)
}

func (s *CommentContext) AllCcontent() []ICcontentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICcontentContext); ok {
			len++
		}
	}

	tst := make([]ICcontentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICcontentContext); ok {
			tst[i] = t.(ICcontentContext)
			i++
		}
	}

	return tst
}

func (s *CommentContext) Ccontent(i int) ICcontentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICcontentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICcontentContext)
}

func (s *CommentContext) AllFws() []IFwsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFwsContext); ok {
			len++
		}
	}

	tst := make([]IFwsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFwsContext); ok {
			tst[i] = t.(IFwsContext)
			i++
		}
	}

	return tst
}

func (s *CommentContext) Fws(i int) IFwsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFwsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFwsContext)
}

func (s *CommentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CommentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CommentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.EnterComment(s)
	}
}

func (s *CommentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.ExitComment(s)
	}
}

func (p *RFC5322Parser) Comment() (localctx ICommentContext) {
	this := p
	_ = this

	localctx = NewCommentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, RFC5322ParserRULE_comment)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(200)
		p.Match(RFC5322ParserLParens)
	}
	p.SetState(207)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 9, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(202)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RFC5322ParserTAB)|(1<<RFC5322ParserCR)|(1<<RFC5322ParserSP))) != 0 {
				{
					p.SetState(201)
					p.Fws()
				}

			}
			{
				p.SetState(204)
				p.Ccontent()
			}

		}
		p.SetState(209)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 9, p.GetParserRuleContext())
	}
	p.SetState(211)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RFC5322ParserTAB)|(1<<RFC5322ParserCR)|(1<<RFC5322ParserSP))) != 0 {
		{
			p.SetState(210)
			p.Fws()
		}

	}
	{
		p.SetState(213)
		p.Match(RFC5322ParserRParens)
	}

	return localctx
}

// ICfwsContext is an interface to support dynamic dispatch.
type ICfwsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCfwsContext differentiates from other interfaces.
	IsCfwsContext()
}

type CfwsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCfwsContext() *CfwsContext {
	var p = new(CfwsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFC5322ParserRULE_cfws
	return p
}

func (*CfwsContext) IsCfwsContext() {}

func NewCfwsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CfwsContext {
	var p = new(CfwsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC5322ParserRULE_cfws

	return p
}

func (s *CfwsContext) GetParser() antlr.Parser { return s.parser }

func (s *CfwsContext) AllComment() []ICommentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICommentContext); ok {
			len++
		}
	}

	tst := make([]ICommentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICommentContext); ok {
			tst[i] = t.(ICommentContext)
			i++
		}
	}

	return tst
}

func (s *CfwsContext) Comment(i int) ICommentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommentContext)
}

func (s *CfwsContext) AllFws() []IFwsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFwsContext); ok {
			len++
		}
	}

	tst := make([]IFwsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFwsContext); ok {
			tst[i] = t.(IFwsContext)
			i++
		}
	}

	return tst
}

func (s *CfwsContext) Fws(i int) IFwsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFwsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFwsContext)
}

func (s *CfwsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CfwsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CfwsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.EnterCfws(s)
	}
}

func (s *CfwsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.ExitCfws(s)
	}
}

func (p *RFC5322Parser) Cfws() (localctx ICfwsContext) {
	this := p
	_ = this

	localctx = NewCfwsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, RFC5322ParserRULE_cfws)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(227)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 14, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(219)
		p.GetErrorHandler().Sync(p)
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				p.SetState(216)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RFC5322ParserTAB)|(1<<RFC5322ParserCR)|(1<<RFC5322ParserSP))) != 0 {
					{
						p.SetState(215)
						p.Fws()
					}

				}
				{
					p.SetState(218)
					p.Comment()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(221)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 12, p.GetParserRuleContext())
		}
		p.SetState(224)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 13, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(223)
				p.Fws()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(226)
			p.Fws()
		}

	}

	return localctx
}

// IAtextContext is an interface to support dynamic dispatch.
type IAtextContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAtextContext differentiates from other interfaces.
	IsAtextContext()
}

type AtextContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAtextContext() *AtextContext {
	var p = new(AtextContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFC5322ParserRULE_atext
	return p
}

func (*AtextContext) IsAtextContext() {}

func NewAtextContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AtextContext {
	var p = new(AtextContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC5322ParserRULE_atext

	return p
}

func (s *AtextContext) GetParser() antlr.Parser { return s.parser }

func (s *AtextContext) Alpha() IAlphaContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlphaContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlphaContext)
}

func (s *AtextContext) Digit() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserDigit, 0)
}

func (s *AtextContext) Exclamation() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserExclamation, 0)
}

func (s *AtextContext) Hash() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserHash, 0)
}

func (s *AtextContext) Dollar() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserDollar, 0)
}

func (s *AtextContext) Percent() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserPercent, 0)
}

func (s *AtextContext) Ampersand() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserAmpersand, 0)
}

func (s *AtextContext) SQuote() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserSQuote, 0)
}

func (s *AtextContext) Asterisk() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserAsterisk, 0)
}

func (s *AtextContext) Plus() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserPlus, 0)
}

func (s *AtextContext) Minus() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserMinus, 0)
}

func (s *AtextContext) Slash() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserSlash, 0)
}

func (s *AtextContext) Equal() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserEqual, 0)
}

func (s *AtextContext) Question() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserQuestion, 0)
}

func (s *AtextContext) Caret() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserCaret, 0)
}

func (s *AtextContext) Underscore() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserUnderscore, 0)
}

func (s *AtextContext) Backtick() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserBacktick, 0)
}

func (s *AtextContext) LCurly() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserLCurly, 0)
}

func (s *AtextContext) Pipe() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserPipe, 0)
}

func (s *AtextContext) RCurly() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserRCurly, 0)
}

func (s *AtextContext) Tilde() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserTilde, 0)
}

func (s *AtextContext) UTF8NonAscii() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserUTF8NonAscii, 0)
}

func (s *AtextContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AtextContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AtextContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.EnterAtext(s)
	}
}

func (s *AtextContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.ExitAtext(s)
	}
}

func (p *RFC5322Parser) Atext() (localctx IAtextContext) {
	this := p
	_ = this

	localctx = NewAtextContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, RFC5322ParserRULE_atext)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(251)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case RFC5322ParserA, RFC5322ParserB, RFC5322ParserC, RFC5322ParserD, RFC5322ParserE, RFC5322ParserF, RFC5322ParserG, RFC5322ParserH, RFC5322ParserI, RFC5322ParserJ, RFC5322ParserK, RFC5322ParserL, RFC5322ParserM, RFC5322ParserN, RFC5322ParserO, RFC5322ParserP, RFC5322ParserQ, RFC5322ParserR, RFC5322ParserS, RFC5322ParserT, RFC5322ParserU, RFC5322ParserV, RFC5322ParserW, RFC5322ParserX, RFC5322ParserY, RFC5322ParserZ:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(229)
			p.Alpha()
		}

	case RFC5322ParserDigit:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(230)
			p.Match(RFC5322ParserDigit)
		}

	case RFC5322ParserExclamation:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(231)
			p.Match(RFC5322ParserExclamation)
		}

	case RFC5322ParserHash:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(232)
			p.Match(RFC5322ParserHash)
		}

	case RFC5322ParserDollar:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(233)
			p.Match(RFC5322ParserDollar)
		}

	case RFC5322ParserPercent:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(234)
			p.Match(RFC5322ParserPercent)
		}

	case RFC5322ParserAmpersand:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(235)
			p.Match(RFC5322ParserAmpersand)
		}

	case RFC5322ParserSQuote:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(236)
			p.Match(RFC5322ParserSQuote)
		}

	case RFC5322ParserAsterisk:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(237)
			p.Match(RFC5322ParserAsterisk)
		}

	case RFC5322ParserPlus:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(238)
			p.Match(RFC5322ParserPlus)
		}

	case RFC5322ParserMinus:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(239)
			p.Match(RFC5322ParserMinus)
		}

	case RFC5322ParserSlash:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(240)
			p.Match(RFC5322ParserSlash)
		}

	case RFC5322ParserEqual:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(241)
			p.Match(RFC5322ParserEqual)
		}

	case RFC5322ParserQuestion:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(242)
			p.Match(RFC5322ParserQuestion)
		}

	case RFC5322ParserCaret:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(243)
			p.Match(RFC5322ParserCaret)
		}

	case RFC5322ParserUnderscore:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(244)
			p.Match(RFC5322ParserUnderscore)
		}

	case RFC5322ParserBacktick:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(245)
			p.Match(RFC5322ParserBacktick)
		}

	case RFC5322ParserLCurly:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(246)
			p.Match(RFC5322ParserLCurly)
		}

	case RFC5322ParserPipe:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(247)
			p.Match(RFC5322ParserPipe)
		}

	case RFC5322ParserRCurly:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(248)
			p.Match(RFC5322ParserRCurly)
		}

	case RFC5322ParserTilde:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(249)
			p.Match(RFC5322ParserTilde)
		}

	case RFC5322ParserUTF8NonAscii:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(250)
			p.Match(RFC5322ParserUTF8NonAscii)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IAtomContext is an interface to support dynamic dispatch.
type IAtomContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAtomContext differentiates from other interfaces.
	IsAtomContext()
}

type AtomContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAtomContext() *AtomContext {
	var p = new(AtomContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFC5322ParserRULE_atom
	return p
}

func (*AtomContext) IsAtomContext() {}

func NewAtomContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AtomContext {
	var p = new(AtomContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC5322ParserRULE_atom

	return p
}

func (s *AtomContext) GetParser() antlr.Parser { return s.parser }

func (s *AtomContext) AllAtext() []IAtextContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAtextContext); ok {
			len++
		}
	}

	tst := make([]IAtextContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAtextContext); ok {
			tst[i] = t.(IAtextContext)
			i++
		}
	}

	return tst
}

func (s *AtomContext) Atext(i int) IAtextContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAtextContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAtextContext)
}

func (s *AtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AtomContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.EnterAtom(s)
	}
}

func (s *AtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.ExitAtom(s)
	}
}

func (p *RFC5322Parser) Atom() (localctx IAtomContext) {
	this := p
	_ = this

	localctx = NewAtomContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, RFC5322ParserRULE_atom)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(254)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(253)
				p.Atext()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(256)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 16, p.GetParserRuleContext())
	}

	return localctx
}

// IDotAtomContext is an interface to support dynamic dispatch.
type IDotAtomContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDotAtomContext differentiates from other interfaces.
	IsDotAtomContext()
}

type DotAtomContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDotAtomContext() *DotAtomContext {
	var p = new(DotAtomContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFC5322ParserRULE_dotAtom
	return p
}

func (*DotAtomContext) IsDotAtomContext() {}

func NewDotAtomContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DotAtomContext {
	var p = new(DotAtomContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC5322ParserRULE_dotAtom

	return p
}

func (s *DotAtomContext) GetParser() antlr.Parser { return s.parser }

func (s *DotAtomContext) AllAtext() []IAtextContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAtextContext); ok {
			len++
		}
	}

	tst := make([]IAtextContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAtextContext); ok {
			tst[i] = t.(IAtextContext)
			i++
		}
	}

	return tst
}

func (s *DotAtomContext) Atext(i int) IAtextContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAtextContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAtextContext)
}

func (s *DotAtomContext) AllPeriod() []antlr.TerminalNode {
	return s.GetTokens(RFC5322ParserPeriod)
}

func (s *DotAtomContext) Period(i int) antlr.TerminalNode {
	return s.GetToken(RFC5322ParserPeriod, i)
}

func (s *DotAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DotAtomContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DotAtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.EnterDotAtom(s)
	}
}

func (s *DotAtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.ExitDotAtom(s)
	}
}

func (p *RFC5322Parser) DotAtom() (localctx IDotAtomContext) {
	this := p
	_ = this

	localctx = NewDotAtomContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, RFC5322ParserRULE_dotAtom)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(259)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la-10)&-(0x1f+1)) == 0 && ((1<<uint((_la-10)))&((1<<(RFC5322ParserExclamation-10))|(1<<(RFC5322ParserHash-10))|(1<<(RFC5322ParserDollar-10))|(1<<(RFC5322ParserPercent-10))|(1<<(RFC5322ParserAmpersand-10))|(1<<(RFC5322ParserSQuote-10))|(1<<(RFC5322ParserAsterisk-10))|(1<<(RFC5322ParserPlus-10))|(1<<(RFC5322ParserMinus-10))|(1<<(RFC5322ParserSlash-10))|(1<<(RFC5322ParserDigit-10))|(1<<(RFC5322ParserEqual-10))|(1<<(RFC5322ParserQuestion-10))|(1<<(RFC5322ParserCaret-10))|(1<<(RFC5322ParserUnderscore-10))|(1<<(RFC5322ParserBacktick-10))|(1<<(RFC5322ParserLCurly-10))|(1<<(RFC5322ParserPipe-10))|(1<<(RFC5322ParserRCurly-10)))) != 0) || (((_la-42)&-(0x1f+1)) == 0 && ((1<<uint((_la-42)))&((1<<(RFC5322ParserTilde-42))|(1<<(RFC5322ParserUTF8NonAscii-42))|(1<<(RFC5322ParserA-42))|(1<<(RFC5322ParserB-42))|(1<<(RFC5322ParserC-42))|(1<<(RFC5322ParserD-42))|(1<<(RFC5322ParserE-42))|(1<<(RFC5322ParserF-42))|(1<<(RFC5322ParserG-42))|(1<<(RFC5322ParserH-42))|(1<<(RFC5322ParserI-42))|(1<<(RFC5322ParserJ-42))|(1<<(RFC5322ParserK-42))|(1<<(RFC5322ParserL-42))|(1<<(RFC5322ParserM-42))|(1<<(RFC5322ParserN-42))|(1<<(RFC5322ParserO-42))|(1<<(RFC5322ParserP-42))|(1<<(RFC5322ParserQ-42))|(1<<(RFC5322ParserR-42))|(1<<(RFC5322ParserS-42))|(1<<(RFC5322ParserT-42))|(1<<(RFC5322ParserU-42))|(1<<(RFC5322ParserV-42))|(1<<(RFC5322ParserW-42))|(1<<(RFC5322ParserX-42))|(1<<(RFC5322ParserY-42))|(1<<(RFC5322ParserZ-42)))) != 0) {
		{
			p.SetState(258)
			p.Atext()
		}

		p.SetState(261)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(271)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 19, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(263)
				p.Match(RFC5322ParserPeriod)
			}
			p.SetState(265)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for ok := true; ok; ok = (((_la-10)&-(0x1f+1)) == 0 && ((1<<uint((_la-10)))&((1<<(RFC5322ParserExclamation-10))|(1<<(RFC5322ParserHash-10))|(1<<(RFC5322ParserDollar-10))|(1<<(RFC5322ParserPercent-10))|(1<<(RFC5322ParserAmpersand-10))|(1<<(RFC5322ParserSQuote-10))|(1<<(RFC5322ParserAsterisk-10))|(1<<(RFC5322ParserPlus-10))|(1<<(RFC5322ParserMinus-10))|(1<<(RFC5322ParserSlash-10))|(1<<(RFC5322ParserDigit-10))|(1<<(RFC5322ParserEqual-10))|(1<<(RFC5322ParserQuestion-10))|(1<<(RFC5322ParserCaret-10))|(1<<(RFC5322ParserUnderscore-10))|(1<<(RFC5322ParserBacktick-10))|(1<<(RFC5322ParserLCurly-10))|(1<<(RFC5322ParserPipe-10))|(1<<(RFC5322ParserRCurly-10)))) != 0) || (((_la-42)&-(0x1f+1)) == 0 && ((1<<uint((_la-42)))&((1<<(RFC5322ParserTilde-42))|(1<<(RFC5322ParserUTF8NonAscii-42))|(1<<(RFC5322ParserA-42))|(1<<(RFC5322ParserB-42))|(1<<(RFC5322ParserC-42))|(1<<(RFC5322ParserD-42))|(1<<(RFC5322ParserE-42))|(1<<(RFC5322ParserF-42))|(1<<(RFC5322ParserG-42))|(1<<(RFC5322ParserH-42))|(1<<(RFC5322ParserI-42))|(1<<(RFC5322ParserJ-42))|(1<<(RFC5322ParserK-42))|(1<<(RFC5322ParserL-42))|(1<<(RFC5322ParserM-42))|(1<<(RFC5322ParserN-42))|(1<<(RFC5322ParserO-42))|(1<<(RFC5322ParserP-42))|(1<<(RFC5322ParserQ-42))|(1<<(RFC5322ParserR-42))|(1<<(RFC5322ParserS-42))|(1<<(RFC5322ParserT-42))|(1<<(RFC5322ParserU-42))|(1<<(RFC5322ParserV-42))|(1<<(RFC5322ParserW-42))|(1<<(RFC5322ParserX-42))|(1<<(RFC5322ParserY-42))|(1<<(RFC5322ParserZ-42)))) != 0) {
				{
					p.SetState(264)
					p.Atext()
				}

				p.SetState(267)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}

		}
		p.SetState(273)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 19, p.GetParserRuleContext())
	}
	p.SetState(275)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == RFC5322ParserPeriod {
		{
			p.SetState(274)
			p.Match(RFC5322ParserPeriod)
		}

	}

	return localctx
}

// IQtextContext is an interface to support dynamic dispatch.
type IQtextContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQtextContext differentiates from other interfaces.
	IsQtextContext()
}

type QtextContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQtextContext() *QtextContext {
	var p = new(QtextContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFC5322ParserRULE_qtext
	return p
}

func (*QtextContext) IsQtextContext() {}

func NewQtextContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QtextContext {
	var p = new(QtextContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC5322ParserRULE_qtext

	return p
}

func (s *QtextContext) GetParser() antlr.Parser { return s.parser }

func (s *QtextContext) Alpha() IAlphaContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlphaContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlphaContext)
}

func (s *QtextContext) Exclamation() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserExclamation, 0)
}

func (s *QtextContext) Hash() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserHash, 0)
}

func (s *QtextContext) Dollar() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserDollar, 0)
}

func (s *QtextContext) Percent() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserPercent, 0)
}

func (s *QtextContext) Ampersand() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserAmpersand, 0)
}

func (s *QtextContext) SQuote() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserSQuote, 0)
}

func (s *QtextContext) LParens() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserLParens, 0)
}

func (s *QtextContext) RParens() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserRParens, 0)
}

func (s *QtextContext) Asterisk() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserAsterisk, 0)
}

func (s *QtextContext) Plus() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserPlus, 0)
}

func (s *QtextContext) Comma() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserComma, 0)
}

func (s *QtextContext) Minus() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserMinus, 0)
}

func (s *QtextContext) Period() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserPeriod, 0)
}

func (s *QtextContext) Slash() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserSlash, 0)
}

func (s *QtextContext) Digit() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserDigit, 0)
}

func (s *QtextContext) Colon() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserColon, 0)
}

func (s *QtextContext) Semicolon() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserSemicolon, 0)
}

func (s *QtextContext) Less() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserLess, 0)
}

func (s *QtextContext) Equal() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserEqual, 0)
}

func (s *QtextContext) Greater() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserGreater, 0)
}

func (s *QtextContext) Question() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserQuestion, 0)
}

func (s *QtextContext) At() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserAt, 0)
}

func (s *QtextContext) LBracket() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserLBracket, 0)
}

func (s *QtextContext) RBracket() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserRBracket, 0)
}

func (s *QtextContext) Caret() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserCaret, 0)
}

func (s *QtextContext) Underscore() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserUnderscore, 0)
}

func (s *QtextContext) Backtick() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserBacktick, 0)
}

func (s *QtextContext) LCurly() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserLCurly, 0)
}

func (s *QtextContext) Pipe() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserPipe, 0)
}

func (s *QtextContext) RCurly() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserRCurly, 0)
}

func (s *QtextContext) Tilde() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserTilde, 0)
}

func (s *QtextContext) ObsQtext() IObsQtextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObsQtextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObsQtextContext)
}

func (s *QtextContext) UTF8NonAscii() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserUTF8NonAscii, 0)
}

func (s *QtextContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QtextContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QtextContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.EnterQtext(s)
	}
}

func (s *QtextContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.ExitQtext(s)
	}
}

func (p *RFC5322Parser) Qtext() (localctx IQtextContext) {
	this := p
	_ = this

	localctx = NewQtextContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, RFC5322ParserRULE_qtext)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(311)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case RFC5322ParserA, RFC5322ParserB, RFC5322ParserC, RFC5322ParserD, RFC5322ParserE, RFC5322ParserF, RFC5322ParserG, RFC5322ParserH, RFC5322ParserI, RFC5322ParserJ, RFC5322ParserK, RFC5322ParserL, RFC5322ParserM, RFC5322ParserN, RFC5322ParserO, RFC5322ParserP, RFC5322ParserQ, RFC5322ParserR, RFC5322ParserS, RFC5322ParserT, RFC5322ParserU, RFC5322ParserV, RFC5322ParserW, RFC5322ParserX, RFC5322ParserY, RFC5322ParserZ:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(277)
			p.Alpha()
		}

	case RFC5322ParserExclamation:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(278)
			p.Match(RFC5322ParserExclamation)
		}

	case RFC5322ParserHash:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(279)
			p.Match(RFC5322ParserHash)
		}

	case RFC5322ParserDollar:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(280)
			p.Match(RFC5322ParserDollar)
		}

	case RFC5322ParserPercent:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(281)
			p.Match(RFC5322ParserPercent)
		}

	case RFC5322ParserAmpersand:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(282)
			p.Match(RFC5322ParserAmpersand)
		}

	case RFC5322ParserSQuote:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(283)
			p.Match(RFC5322ParserSQuote)
		}

	case RFC5322ParserLParens:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(284)
			p.Match(RFC5322ParserLParens)
		}

	case RFC5322ParserRParens:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(285)
			p.Match(RFC5322ParserRParens)
		}

	case RFC5322ParserAsterisk:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(286)
			p.Match(RFC5322ParserAsterisk)
		}

	case RFC5322ParserPlus:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(287)
			p.Match(RFC5322ParserPlus)
		}

	case RFC5322ParserComma:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(288)
			p.Match(RFC5322ParserComma)
		}

	case RFC5322ParserMinus:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(289)
			p.Match(RFC5322ParserMinus)
		}

	case RFC5322ParserPeriod:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(290)
			p.Match(RFC5322ParserPeriod)
		}

	case RFC5322ParserSlash:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(291)
			p.Match(RFC5322ParserSlash)
		}

	case RFC5322ParserDigit:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(292)
			p.Match(RFC5322ParserDigit)
		}

	case RFC5322ParserColon:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(293)
			p.Match(RFC5322ParserColon)
		}

	case RFC5322ParserSemicolon:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(294)
			p.Match(RFC5322ParserSemicolon)
		}

	case RFC5322ParserLess:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(295)
			p.Match(RFC5322ParserLess)
		}

	case RFC5322ParserEqual:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(296)
			p.Match(RFC5322ParserEqual)
		}

	case RFC5322ParserGreater:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(297)
			p.Match(RFC5322ParserGreater)
		}

	case RFC5322ParserQuestion:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(298)
			p.Match(RFC5322ParserQuestion)
		}

	case RFC5322ParserAt:
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(299)
			p.Match(RFC5322ParserAt)
		}

	case RFC5322ParserLBracket:
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(300)
			p.Match(RFC5322ParserLBracket)
		}

	case RFC5322ParserRBracket:
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(301)
			p.Match(RFC5322ParserRBracket)
		}

	case RFC5322ParserCaret:
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(302)
			p.Match(RFC5322ParserCaret)
		}

	case RFC5322ParserUnderscore:
		p.EnterOuterAlt(localctx, 27)
		{
			p.SetState(303)
			p.Match(RFC5322ParserUnderscore)
		}

	case RFC5322ParserBacktick:
		p.EnterOuterAlt(localctx, 28)
		{
			p.SetState(304)
			p.Match(RFC5322ParserBacktick)
		}

	case RFC5322ParserLCurly:
		p.EnterOuterAlt(localctx, 29)
		{
			p.SetState(305)
			p.Match(RFC5322ParserLCurly)
		}

	case RFC5322ParserPipe:
		p.EnterOuterAlt(localctx, 30)
		{
			p.SetState(306)
			p.Match(RFC5322ParserPipe)
		}

	case RFC5322ParserRCurly:
		p.EnterOuterAlt(localctx, 31)
		{
			p.SetState(307)
			p.Match(RFC5322ParserRCurly)
		}

	case RFC5322ParserTilde:
		p.EnterOuterAlt(localctx, 32)
		{
			p.SetState(308)
			p.Match(RFC5322ParserTilde)
		}

	case RFC5322ParserU_01_08, RFC5322ParserU_0B, RFC5322ParserU_0C, RFC5322ParserU_0E_1F, RFC5322ParserDelete:
		p.EnterOuterAlt(localctx, 33)
		{
			p.SetState(309)
			p.ObsQtext()
		}

	case RFC5322ParserUTF8NonAscii:
		p.EnterOuterAlt(localctx, 34)
		{
			p.SetState(310)
			p.Match(RFC5322ParserUTF8NonAscii)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IQuotedContentContext is an interface to support dynamic dispatch.
type IQuotedContentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQuotedContentContext differentiates from other interfaces.
	IsQuotedContentContext()
}

type QuotedContentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQuotedContentContext() *QuotedContentContext {
	var p = new(QuotedContentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFC5322ParserRULE_quotedContent
	return p
}

func (*QuotedContentContext) IsQuotedContentContext() {}

func NewQuotedContentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QuotedContentContext {
	var p = new(QuotedContentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC5322ParserRULE_quotedContent

	return p
}

func (s *QuotedContentContext) GetParser() antlr.Parser { return s.parser }

func (s *QuotedContentContext) Qtext() IQtextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQtextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQtextContext)
}

func (s *QuotedContentContext) QuotedPair() IQuotedPairContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQuotedPairContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQuotedPairContext)
}

func (s *QuotedContentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QuotedContentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QuotedContentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.EnterQuotedContent(s)
	}
}

func (s *QuotedContentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.ExitQuotedContent(s)
	}
}

func (p *RFC5322Parser) QuotedContent() (localctx IQuotedContentContext) {
	this := p
	_ = this

	localctx = NewQuotedContentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, RFC5322ParserRULE_quotedContent)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(315)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case RFC5322ParserU_01_08, RFC5322ParserU_0B, RFC5322ParserU_0C, RFC5322ParserU_0E_1F, RFC5322ParserExclamation, RFC5322ParserHash, RFC5322ParserDollar, RFC5322ParserPercent, RFC5322ParserAmpersand, RFC5322ParserSQuote, RFC5322ParserLParens, RFC5322ParserRParens, RFC5322ParserAsterisk, RFC5322ParserPlus, RFC5322ParserComma, RFC5322ParserMinus, RFC5322ParserPeriod, RFC5322ParserSlash, RFC5322ParserDigit, RFC5322ParserColon, RFC5322ParserSemicolon, RFC5322ParserLess, RFC5322ParserEqual, RFC5322ParserGreater, RFC5322ParserQuestion, RFC5322ParserAt, RFC5322ParserLBracket, RFC5322ParserRBracket, RFC5322ParserCaret, RFC5322ParserUnderscore, RFC5322ParserBacktick, RFC5322ParserLCurly, RFC5322ParserPipe, RFC5322ParserRCurly, RFC5322ParserTilde, RFC5322ParserDelete, RFC5322ParserUTF8NonAscii, RFC5322ParserA, RFC5322ParserB, RFC5322ParserC, RFC5322ParserD, RFC5322ParserE, RFC5322ParserF, RFC5322ParserG, RFC5322ParserH, RFC5322ParserI, RFC5322ParserJ, RFC5322ParserK, RFC5322ParserL, RFC5322ParserM, RFC5322ParserN, RFC5322ParserO, RFC5322ParserP, RFC5322ParserQ, RFC5322ParserR, RFC5322ParserS, RFC5322ParserT, RFC5322ParserU, RFC5322ParserV, RFC5322ParserW, RFC5322ParserX, RFC5322ParserY, RFC5322ParserZ:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(313)
			p.Qtext()
		}

	case RFC5322ParserBackslash:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(314)
			p.QuotedPair()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IQuotedValueContext is an interface to support dynamic dispatch.
type IQuotedValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQuotedValueContext differentiates from other interfaces.
	IsQuotedValueContext()
}

type QuotedValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQuotedValueContext() *QuotedValueContext {
	var p = new(QuotedValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFC5322ParserRULE_quotedValue
	return p
}

func (*QuotedValueContext) IsQuotedValueContext() {}

func NewQuotedValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QuotedValueContext {
	var p = new(QuotedValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC5322ParserRULE_quotedValue

	return p
}

func (s *QuotedValueContext) GetParser() antlr.Parser { return s.parser }

func (s *QuotedValueContext) AllQuotedContent() []IQuotedContentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQuotedContentContext); ok {
			len++
		}
	}

	tst := make([]IQuotedContentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQuotedContentContext); ok {
			tst[i] = t.(IQuotedContentContext)
			i++
		}
	}

	return tst
}

func (s *QuotedValueContext) QuotedContent(i int) IQuotedContentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQuotedContentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQuotedContentContext)
}

func (s *QuotedValueContext) AllFws() []IFwsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFwsContext); ok {
			len++
		}
	}

	tst := make([]IFwsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFwsContext); ok {
			tst[i] = t.(IFwsContext)
			i++
		}
	}

	return tst
}

func (s *QuotedValueContext) Fws(i int) IFwsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFwsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFwsContext)
}

func (s *QuotedValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QuotedValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QuotedValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.EnterQuotedValue(s)
	}
}

func (s *QuotedValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.ExitQuotedValue(s)
	}
}

func (p *RFC5322Parser) QuotedValue() (localctx IQuotedValueContext) {
	this := p
	_ = this

	localctx = NewQuotedValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, RFC5322ParserRULE_quotedValue)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(323)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 24, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(318)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RFC5322ParserTAB)|(1<<RFC5322ParserCR)|(1<<RFC5322ParserSP))) != 0 {
				{
					p.SetState(317)
					p.Fws()
				}

			}
			{
				p.SetState(320)
				p.QuotedContent()
			}

		}
		p.SetState(325)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 24, p.GetParserRuleContext())
	}

	return localctx
}

// IQuotedStringContext is an interface to support dynamic dispatch.
type IQuotedStringContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQuotedStringContext differentiates from other interfaces.
	IsQuotedStringContext()
}

type QuotedStringContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQuotedStringContext() *QuotedStringContext {
	var p = new(QuotedStringContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFC5322ParserRULE_quotedString
	return p
}

func (*QuotedStringContext) IsQuotedStringContext() {}

func NewQuotedStringContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QuotedStringContext {
	var p = new(QuotedStringContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC5322ParserRULE_quotedString

	return p
}

func (s *QuotedStringContext) GetParser() antlr.Parser { return s.parser }

func (s *QuotedStringContext) AllDQuote() []antlr.TerminalNode {
	return s.GetTokens(RFC5322ParserDQuote)
}

func (s *QuotedStringContext) DQuote(i int) antlr.TerminalNode {
	return s.GetToken(RFC5322ParserDQuote, i)
}

func (s *QuotedStringContext) QuotedValue() IQuotedValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQuotedValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQuotedValueContext)
}

func (s *QuotedStringContext) Fws() IFwsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFwsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFwsContext)
}

func (s *QuotedStringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QuotedStringContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QuotedStringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.EnterQuotedString(s)
	}
}

func (s *QuotedStringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.ExitQuotedString(s)
	}
}

func (p *RFC5322Parser) QuotedString() (localctx IQuotedStringContext) {
	this := p
	_ = this

	localctx = NewQuotedStringContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, RFC5322ParserRULE_quotedString)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(326)
		p.Match(RFC5322ParserDQuote)
	}
	{
		p.SetState(327)
		p.QuotedValue()
	}
	p.SetState(329)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RFC5322ParserTAB)|(1<<RFC5322ParserCR)|(1<<RFC5322ParserSP))) != 0 {
		{
			p.SetState(328)
			p.Fws()
		}

	}
	{
		p.SetState(331)
		p.Match(RFC5322ParserDQuote)
	}

	return localctx
}

// IWordContext is an interface to support dynamic dispatch.
type IWordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWordContext differentiates from other interfaces.
	IsWordContext()
}

type WordContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWordContext() *WordContext {
	var p = new(WordContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFC5322ParserRULE_word
	return p
}

func (*WordContext) IsWordContext() {}

func NewWordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WordContext {
	var p = new(WordContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC5322ParserRULE_word

	return p
}

func (s *WordContext) GetParser() antlr.Parser { return s.parser }

func (s *WordContext) AllEncodedWord() []IEncodedWordContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEncodedWordContext); ok {
			len++
		}
	}

	tst := make([]IEncodedWordContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEncodedWordContext); ok {
			tst[i] = t.(IEncodedWordContext)
			i++
		}
	}

	return tst
}

func (s *WordContext) EncodedWord(i int) IEncodedWordContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEncodedWordContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEncodedWordContext)
}

func (s *WordContext) AllCfws() []ICfwsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICfwsContext); ok {
			len++
		}
	}

	tst := make([]ICfwsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICfwsContext); ok {
			tst[i] = t.(ICfwsContext)
			i++
		}
	}

	return tst
}

func (s *WordContext) Cfws(i int) ICfwsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICfwsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICfwsContext)
}

func (s *WordContext) Atom() IAtomContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAtomContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAtomContext)
}

func (s *WordContext) QuotedString() IQuotedStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQuotedStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQuotedStringContext)
}

func (s *WordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.EnterWord(s)
	}
}

func (s *WordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.ExitWord(s)
	}
}

func (p *RFC5322Parser) Word() (localctx IWordContext) {
	this := p
	_ = this

	localctx = NewWordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, RFC5322ParserRULE_word)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(358)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 33, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(340)
		p.GetErrorHandler().Sync(p)
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				p.SetState(334)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RFC5322ParserTAB)|(1<<RFC5322ParserCR)|(1<<RFC5322ParserSP)|(1<<RFC5322ParserLParens))) != 0 {
					{
						p.SetState(333)
						p.Cfws()
					}

				}
				{
					p.SetState(336)
					p.EncodedWord()
				}
				p.SetState(338)
				p.GetErrorHandler().Sync(p)

				if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 27, p.GetParserRuleContext()) == 1 {
					{
						p.SetState(337)
						p.Cfws()
					}

				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(342)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 28, p.GetParserRuleContext())
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(345)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RFC5322ParserTAB)|(1<<RFC5322ParserCR)|(1<<RFC5322ParserSP)|(1<<RFC5322ParserLParens))) != 0 {
			{
				p.SetState(344)
				p.Cfws()
			}

		}
		{
			p.SetState(347)
			p.Atom()
		}
		p.SetState(349)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 30, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(348)
				p.Cfws()
			}

		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(352)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RFC5322ParserTAB)|(1<<RFC5322ParserCR)|(1<<RFC5322ParserSP)|(1<<RFC5322ParserLParens))) != 0 {
			{
				p.SetState(351)
				p.Cfws()
			}

		}
		{
			p.SetState(354)
			p.QuotedString()
		}
		p.SetState(356)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 32, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(355)
				p.Cfws()
			}

		}

	}

	return localctx
}

// IDateTimeContext is an interface to support dynamic dispatch.
type IDateTimeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDateTimeContext differentiates from other interfaces.
	IsDateTimeContext()
}

type DateTimeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDateTimeContext() *DateTimeContext {
	var p = new(DateTimeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFC5322ParserRULE_dateTime
	return p
}

func (*DateTimeContext) IsDateTimeContext() {}

func NewDateTimeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DateTimeContext {
	var p = new(DateTimeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC5322ParserRULE_dateTime

	return p
}

func (s *DateTimeContext) GetParser() antlr.Parser { return s.parser }

func (s *DateTimeContext) Day() IDayContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDayContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDayContext)
}

func (s *DateTimeContext) Month() IMonthContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMonthContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMonthContext)
}

func (s *DateTimeContext) Year() IYearContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IYearContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IYearContext)
}

func (s *DateTimeContext) Hour() IHourContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHourContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHourContext)
}

func (s *DateTimeContext) AllColon() []antlr.TerminalNode {
	return s.GetTokens(RFC5322ParserColon)
}

func (s *DateTimeContext) Colon(i int) antlr.TerminalNode {
	return s.GetToken(RFC5322ParserColon, i)
}

func (s *DateTimeContext) Minute() IMinuteContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMinuteContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMinuteContext)
}

func (s *DateTimeContext) EOF() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserEOF, 0)
}

func (s *DateTimeContext) DayOfweek() IDayOfweekContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDayOfweekContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDayOfweekContext)
}

func (s *DateTimeContext) Comma() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserComma, 0)
}

func (s *DateTimeContext) Second() ISecondContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISecondContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISecondContext)
}

func (s *DateTimeContext) Zone() IZoneContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IZoneContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IZoneContext)
}

func (s *DateTimeContext) Cfws() ICfwsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICfwsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICfwsContext)
}

func (s *DateTimeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DateTimeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DateTimeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.EnterDateTime(s)
	}
}

func (s *DateTimeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.ExitDateTime(s)
	}
}

func (p *RFC5322Parser) DateTime() (localctx IDateTimeContext) {
	this := p
	_ = this

	localctx = NewDateTimeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, RFC5322ParserRULE_dateTime)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(363)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 34, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(360)
			p.DayOfweek()
		}
		{
			p.SetState(361)
			p.Match(RFC5322ParserComma)
		}

	}
	{
		p.SetState(365)
		p.Day()
	}
	{
		p.SetState(366)
		p.Month()
	}
	{
		p.SetState(367)
		p.Year()
	}
	{
		p.SetState(368)
		p.Hour()
	}
	{
		p.SetState(369)
		p.Match(RFC5322ParserColon)
	}
	{
		p.SetState(370)
		p.Minute()
	}
	p.SetState(373)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == RFC5322ParserColon {
		{
			p.SetState(371)
			p.Match(RFC5322ParserColon)
		}
		{
			p.SetState(372)
			p.Second()
		}

	}
	p.SetState(376)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 36, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(375)
			p.Zone()
		}

	}
	p.SetState(379)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RFC5322ParserTAB)|(1<<RFC5322ParserCR)|(1<<RFC5322ParserSP)|(1<<RFC5322ParserLParens))) != 0 {
		{
			p.SetState(378)
			p.Cfws()
		}

	}
	{
		p.SetState(381)
		p.Match(RFC5322ParserEOF)
	}

	return localctx
}

// IDayOfweekContext is an interface to support dynamic dispatch.
type IDayOfweekContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDayOfweekContext differentiates from other interfaces.
	IsDayOfweekContext()
}

type DayOfweekContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDayOfweekContext() *DayOfweekContext {
	var p = new(DayOfweekContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFC5322ParserRULE_dayOfweek
	return p
}

func (*DayOfweekContext) IsDayOfweekContext() {}

func NewDayOfweekContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DayOfweekContext {
	var p = new(DayOfweekContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC5322ParserRULE_dayOfweek

	return p
}

func (s *DayOfweekContext) GetParser() antlr.Parser { return s.parser }

func (s *DayOfweekContext) DayName() IDayNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDayNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDayNameContext)
}

func (s *DayOfweekContext) Fws() IFwsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFwsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFwsContext)
}

func (s *DayOfweekContext) AllCfws() []ICfwsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICfwsContext); ok {
			len++
		}
	}

	tst := make([]ICfwsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICfwsContext); ok {
			tst[i] = t.(ICfwsContext)
			i++
		}
	}

	return tst
}

func (s *DayOfweekContext) Cfws(i int) ICfwsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICfwsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICfwsContext)
}

func (s *DayOfweekContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DayOfweekContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DayOfweekContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.EnterDayOfweek(s)
	}
}

func (s *DayOfweekContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.ExitDayOfweek(s)
	}
}

func (p *RFC5322Parser) DayOfweek() (localctx IDayOfweekContext) {
	this := p
	_ = this

	localctx = NewDayOfweekContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, RFC5322ParserRULE_dayOfweek)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(394)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 41, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(384)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RFC5322ParserTAB)|(1<<RFC5322ParserCR)|(1<<RFC5322ParserSP))) != 0 {
			{
				p.SetState(383)
				p.Fws()
			}

		}
		{
			p.SetState(386)
			p.DayName()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(388)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RFC5322ParserTAB)|(1<<RFC5322ParserCR)|(1<<RFC5322ParserSP)|(1<<RFC5322ParserLParens))) != 0 {
			{
				p.SetState(387)
				p.Cfws()
			}

		}
		{
			p.SetState(390)
			p.DayName()
		}
		p.SetState(392)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RFC5322ParserTAB)|(1<<RFC5322ParserCR)|(1<<RFC5322ParserSP)|(1<<RFC5322ParserLParens))) != 0 {
			{
				p.SetState(391)
				p.Cfws()
			}

		}

	}

	return localctx
}

// IDayNameContext is an interface to support dynamic dispatch.
type IDayNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDayNameContext differentiates from other interfaces.
	IsDayNameContext()
}

type DayNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDayNameContext() *DayNameContext {
	var p = new(DayNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFC5322ParserRULE_dayName
	return p
}

func (*DayNameContext) IsDayNameContext() {}

func NewDayNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DayNameContext {
	var p = new(DayNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC5322ParserRULE_dayName

	return p
}

func (s *DayNameContext) GetParser() antlr.Parser { return s.parser }

func (s *DayNameContext) M() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserM, 0)
}

func (s *DayNameContext) O() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserO, 0)
}

func (s *DayNameContext) N() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserN, 0)
}

func (s *DayNameContext) T() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserT, 0)
}

func (s *DayNameContext) U() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserU, 0)
}

func (s *DayNameContext) E() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserE, 0)
}

func (s *DayNameContext) W() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserW, 0)
}

func (s *DayNameContext) D() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserD, 0)
}

func (s *DayNameContext) H() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserH, 0)
}

func (s *DayNameContext) F() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserF, 0)
}

func (s *DayNameContext) R() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserR, 0)
}

func (s *DayNameContext) I() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserI, 0)
}

func (s *DayNameContext) S() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserS, 0)
}

func (s *DayNameContext) A() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserA, 0)
}

func (s *DayNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DayNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DayNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.EnterDayName(s)
	}
}

func (s *DayNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.ExitDayName(s)
	}
}

func (p *RFC5322Parser) DayName() (localctx IDayNameContext) {
	this := p
	_ = this

	localctx = NewDayNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, RFC5322ParserRULE_dayName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(417)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 42, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(396)
			p.Match(RFC5322ParserM)
		}
		{
			p.SetState(397)
			p.Match(RFC5322ParserO)
		}
		{
			p.SetState(398)
			p.Match(RFC5322ParserN)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(399)
			p.Match(RFC5322ParserT)
		}
		{
			p.SetState(400)
			p.Match(RFC5322ParserU)
		}
		{
			p.SetState(401)
			p.Match(RFC5322ParserE)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(402)
			p.Match(RFC5322ParserW)
		}
		{
			p.SetState(403)
			p.Match(RFC5322ParserE)
		}
		{
			p.SetState(404)
			p.Match(RFC5322ParserD)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(405)
			p.Match(RFC5322ParserT)
		}
		{
			p.SetState(406)
			p.Match(RFC5322ParserH)
		}
		{
			p.SetState(407)
			p.Match(RFC5322ParserU)
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(408)
			p.Match(RFC5322ParserF)
		}
		{
			p.SetState(409)
			p.Match(RFC5322ParserR)
		}
		{
			p.SetState(410)
			p.Match(RFC5322ParserI)
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(411)
			p.Match(RFC5322ParserS)
		}
		{
			p.SetState(412)
			p.Match(RFC5322ParserA)
		}
		{
			p.SetState(413)
			p.Match(RFC5322ParserT)
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(414)
			p.Match(RFC5322ParserS)
		}
		{
			p.SetState(415)
			p.Match(RFC5322ParserU)
		}
		{
			p.SetState(416)
			p.Match(RFC5322ParserN)
		}

	}

	return localctx
}

// IDayContext is an interface to support dynamic dispatch.
type IDayContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDayContext differentiates from other interfaces.
	IsDayContext()
}

type DayContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDayContext() *DayContext {
	var p = new(DayContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFC5322ParserRULE_day
	return p
}

func (*DayContext) IsDayContext() {}

func NewDayContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DayContext {
	var p = new(DayContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC5322ParserRULE_day

	return p
}

func (s *DayContext) GetParser() antlr.Parser { return s.parser }

func (s *DayContext) AllDigit() []antlr.TerminalNode {
	return s.GetTokens(RFC5322ParserDigit)
}

func (s *DayContext) Digit(i int) antlr.TerminalNode {
	return s.GetToken(RFC5322ParserDigit, i)
}

func (s *DayContext) AllFws() []IFwsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFwsContext); ok {
			len++
		}
	}

	tst := make([]IFwsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFwsContext); ok {
			tst[i] = t.(IFwsContext)
			i++
		}
	}

	return tst
}

func (s *DayContext) Fws(i int) IFwsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFwsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFwsContext)
}

func (s *DayContext) AllCfws() []ICfwsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICfwsContext); ok {
			len++
		}
	}

	tst := make([]ICfwsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICfwsContext); ok {
			tst[i] = t.(ICfwsContext)
			i++
		}
	}

	return tst
}

func (s *DayContext) Cfws(i int) ICfwsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICfwsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICfwsContext)
}

func (s *DayContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DayContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DayContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.EnterDay(s)
	}
}

func (s *DayContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.ExitDay(s)
	}
}

func (p *RFC5322Parser) Day() (localctx IDayContext) {
	this := p
	_ = this

	localctx = NewDayContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, RFC5322ParserRULE_day)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(437)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 48, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(420)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RFC5322ParserTAB)|(1<<RFC5322ParserCR)|(1<<RFC5322ParserSP))) != 0 {
			{
				p.SetState(419)
				p.Fws()
			}

		}
		{
			p.SetState(422)
			p.Match(RFC5322ParserDigit)
		}
		p.SetState(424)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == RFC5322ParserDigit {
			{
				p.SetState(423)
				p.Match(RFC5322ParserDigit)
			}

		}
		{
			p.SetState(426)
			p.Fws()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(428)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RFC5322ParserTAB)|(1<<RFC5322ParserCR)|(1<<RFC5322ParserSP)|(1<<RFC5322ParserLParens))) != 0 {
			{
				p.SetState(427)
				p.Cfws()
			}

		}
		{
			p.SetState(430)
			p.Match(RFC5322ParserDigit)
		}
		p.SetState(432)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == RFC5322ParserDigit {
			{
				p.SetState(431)
				p.Match(RFC5322ParserDigit)
			}

		}
		p.SetState(435)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RFC5322ParserTAB)|(1<<RFC5322ParserCR)|(1<<RFC5322ParserSP)|(1<<RFC5322ParserLParens))) != 0 {
			{
				p.SetState(434)
				p.Cfws()
			}

		}

	}

	return localctx
}

// IMonthContext is an interface to support dynamic dispatch.
type IMonthContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMonthContext differentiates from other interfaces.
	IsMonthContext()
}

type MonthContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMonthContext() *MonthContext {
	var p = new(MonthContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFC5322ParserRULE_month
	return p
}

func (*MonthContext) IsMonthContext() {}

func NewMonthContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MonthContext {
	var p = new(MonthContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC5322ParserRULE_month

	return p
}

func (s *MonthContext) GetParser() antlr.Parser { return s.parser }

func (s *MonthContext) J() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserJ, 0)
}

func (s *MonthContext) A() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserA, 0)
}

func (s *MonthContext) N() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserN, 0)
}

func (s *MonthContext) F() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserF, 0)
}

func (s *MonthContext) E() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserE, 0)
}

func (s *MonthContext) B() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserB, 0)
}

func (s *MonthContext) M() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserM, 0)
}

func (s *MonthContext) R() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserR, 0)
}

func (s *MonthContext) P() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserP, 0)
}

func (s *MonthContext) Y() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserY, 0)
}

func (s *MonthContext) U() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserU, 0)
}

func (s *MonthContext) L() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserL, 0)
}

func (s *MonthContext) G() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserG, 0)
}

func (s *MonthContext) S() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserS, 0)
}

func (s *MonthContext) O() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserO, 0)
}

func (s *MonthContext) C() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserC, 0)
}

func (s *MonthContext) T() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserT, 0)
}

func (s *MonthContext) V() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserV, 0)
}

func (s *MonthContext) D() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserD, 0)
}

func (s *MonthContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MonthContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MonthContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.EnterMonth(s)
	}
}

func (s *MonthContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.ExitMonth(s)
	}
}

func (p *RFC5322Parser) Month() (localctx IMonthContext) {
	this := p
	_ = this

	localctx = NewMonthContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, RFC5322ParserRULE_month)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(475)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 49, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(439)
			p.Match(RFC5322ParserJ)
		}
		{
			p.SetState(440)
			p.Match(RFC5322ParserA)
		}
		{
			p.SetState(441)
			p.Match(RFC5322ParserN)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(442)
			p.Match(RFC5322ParserF)
		}
		{
			p.SetState(443)
			p.Match(RFC5322ParserE)
		}
		{
			p.SetState(444)
			p.Match(RFC5322ParserB)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(445)
			p.Match(RFC5322ParserM)
		}
		{
			p.SetState(446)
			p.Match(RFC5322ParserA)
		}
		{
			p.SetState(447)
			p.Match(RFC5322ParserR)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(448)
			p.Match(RFC5322ParserA)
		}
		{
			p.SetState(449)
			p.Match(RFC5322ParserP)
		}
		{
			p.SetState(450)
			p.Match(RFC5322ParserR)
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(451)
			p.Match(RFC5322ParserM)
		}
		{
			p.SetState(452)
			p.Match(RFC5322ParserA)
		}
		{
			p.SetState(453)
			p.Match(RFC5322ParserY)
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(454)
			p.Match(RFC5322ParserJ)
		}
		{
			p.SetState(455)
			p.Match(RFC5322ParserU)
		}
		{
			p.SetState(456)
			p.Match(RFC5322ParserN)
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(457)
			p.Match(RFC5322ParserJ)
		}
		{
			p.SetState(458)
			p.Match(RFC5322ParserU)
		}
		{
			p.SetState(459)
			p.Match(RFC5322ParserL)
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(460)
			p.Match(RFC5322ParserA)
		}
		{
			p.SetState(461)
			p.Match(RFC5322ParserU)
		}
		{
			p.SetState(462)
			p.Match(RFC5322ParserG)
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(463)
			p.Match(RFC5322ParserS)
		}
		{
			p.SetState(464)
			p.Match(RFC5322ParserE)
		}
		{
			p.SetState(465)
			p.Match(RFC5322ParserP)
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(466)
			p.Match(RFC5322ParserO)
		}
		{
			p.SetState(467)
			p.Match(RFC5322ParserC)
		}
		{
			p.SetState(468)
			p.Match(RFC5322ParserT)
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(469)
			p.Match(RFC5322ParserN)
		}
		{
			p.SetState(470)
			p.Match(RFC5322ParserO)
		}
		{
			p.SetState(471)
			p.Match(RFC5322ParserV)
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(472)
			p.Match(RFC5322ParserD)
		}
		{
			p.SetState(473)
			p.Match(RFC5322ParserE)
		}
		{
			p.SetState(474)
			p.Match(RFC5322ParserC)
		}

	}

	return localctx
}

// IYearContext is an interface to support dynamic dispatch.
type IYearContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsYearContext differentiates from other interfaces.
	IsYearContext()
}

type YearContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyYearContext() *YearContext {
	var p = new(YearContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFC5322ParserRULE_year
	return p
}

func (*YearContext) IsYearContext() {}

func NewYearContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *YearContext {
	var p = new(YearContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC5322ParserRULE_year

	return p
}

func (s *YearContext) GetParser() antlr.Parser { return s.parser }

func (s *YearContext) AllFws() []IFwsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFwsContext); ok {
			len++
		}
	}

	tst := make([]IFwsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFwsContext); ok {
			tst[i] = t.(IFwsContext)
			i++
		}
	}

	return tst
}

func (s *YearContext) Fws(i int) IFwsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFwsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFwsContext)
}

func (s *YearContext) AllDigit() []antlr.TerminalNode {
	return s.GetTokens(RFC5322ParserDigit)
}

func (s *YearContext) Digit(i int) antlr.TerminalNode {
	return s.GetToken(RFC5322ParserDigit, i)
}

func (s *YearContext) AllCfws() []ICfwsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICfwsContext); ok {
			len++
		}
	}

	tst := make([]ICfwsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICfwsContext); ok {
			tst[i] = t.(ICfwsContext)
			i++
		}
	}

	return tst
}

func (s *YearContext) Cfws(i int) ICfwsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICfwsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICfwsContext)
}

func (s *YearContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *YearContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *YearContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.EnterYear(s)
	}
}

func (s *YearContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.ExitYear(s)
	}
}

func (p *RFC5322Parser) Year() (localctx IYearContext) {
	this := p
	_ = this

	localctx = NewYearContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, RFC5322ParserRULE_year)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(492)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 52, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(477)
			p.Fws()
		}
		{
			p.SetState(478)
			p.Match(RFC5322ParserDigit)
		}
		{
			p.SetState(479)
			p.Match(RFC5322ParserDigit)
		}
		{
			p.SetState(480)
			p.Match(RFC5322ParserDigit)
		}
		{
			p.SetState(481)
			p.Match(RFC5322ParserDigit)
		}
		{
			p.SetState(482)
			p.Fws()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(485)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RFC5322ParserTAB)|(1<<RFC5322ParserCR)|(1<<RFC5322ParserSP)|(1<<RFC5322ParserLParens))) != 0 {
			{
				p.SetState(484)
				p.Cfws()
			}

		}
		{
			p.SetState(487)
			p.Match(RFC5322ParserDigit)
		}
		{
			p.SetState(488)
			p.Match(RFC5322ParserDigit)
		}
		p.SetState(490)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 51, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(489)
				p.Cfws()
			}

		}

	}

	return localctx
}

// IHourContext is an interface to support dynamic dispatch.
type IHourContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHourContext differentiates from other interfaces.
	IsHourContext()
}

type HourContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHourContext() *HourContext {
	var p = new(HourContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFC5322ParserRULE_hour
	return p
}

func (*HourContext) IsHourContext() {}

func NewHourContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HourContext {
	var p = new(HourContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC5322ParserRULE_hour

	return p
}

func (s *HourContext) GetParser() antlr.Parser { return s.parser }

func (s *HourContext) AllDigit() []antlr.TerminalNode {
	return s.GetTokens(RFC5322ParserDigit)
}

func (s *HourContext) Digit(i int) antlr.TerminalNode {
	return s.GetToken(RFC5322ParserDigit, i)
}

func (s *HourContext) AllCfws() []ICfwsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICfwsContext); ok {
			len++
		}
	}

	tst := make([]ICfwsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICfwsContext); ok {
			tst[i] = t.(ICfwsContext)
			i++
		}
	}

	return tst
}

func (s *HourContext) Cfws(i int) ICfwsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICfwsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICfwsContext)
}

func (s *HourContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HourContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HourContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.EnterHour(s)
	}
}

func (s *HourContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.ExitHour(s)
	}
}

func (p *RFC5322Parser) Hour() (localctx IHourContext) {
	this := p
	_ = this

	localctx = NewHourContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, RFC5322ParserRULE_hour)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(508)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 57, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(495)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 53, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(494)
				p.Match(RFC5322ParserDigit)
			}

		}
		{
			p.SetState(497)
			p.Match(RFC5322ParserDigit)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(499)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RFC5322ParserTAB)|(1<<RFC5322ParserCR)|(1<<RFC5322ParserSP)|(1<<RFC5322ParserLParens))) != 0 {
			{
				p.SetState(498)
				p.Cfws()
			}

		}
		p.SetState(502)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 55, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(501)
				p.Match(RFC5322ParserDigit)
			}

		}
		{
			p.SetState(504)
			p.Match(RFC5322ParserDigit)
		}
		p.SetState(506)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RFC5322ParserTAB)|(1<<RFC5322ParserCR)|(1<<RFC5322ParserSP)|(1<<RFC5322ParserLParens))) != 0 {
			{
				p.SetState(505)
				p.Cfws()
			}

		}

	}

	return localctx
}

// IMinuteContext is an interface to support dynamic dispatch.
type IMinuteContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMinuteContext differentiates from other interfaces.
	IsMinuteContext()
}

type MinuteContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMinuteContext() *MinuteContext {
	var p = new(MinuteContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFC5322ParserRULE_minute
	return p
}

func (*MinuteContext) IsMinuteContext() {}

func NewMinuteContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MinuteContext {
	var p = new(MinuteContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC5322ParserRULE_minute

	return p
}

func (s *MinuteContext) GetParser() antlr.Parser { return s.parser }

func (s *MinuteContext) AllDigit() []antlr.TerminalNode {
	return s.GetTokens(RFC5322ParserDigit)
}

func (s *MinuteContext) Digit(i int) antlr.TerminalNode {
	return s.GetToken(RFC5322ParserDigit, i)
}

func (s *MinuteContext) AllCfws() []ICfwsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICfwsContext); ok {
			len++
		}
	}

	tst := make([]ICfwsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICfwsContext); ok {
			tst[i] = t.(ICfwsContext)
			i++
		}
	}

	return tst
}

func (s *MinuteContext) Cfws(i int) ICfwsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICfwsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICfwsContext)
}

func (s *MinuteContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MinuteContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MinuteContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.EnterMinute(s)
	}
}

func (s *MinuteContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.ExitMinute(s)
	}
}

func (p *RFC5322Parser) Minute() (localctx IMinuteContext) {
	this := p
	_ = this

	localctx = NewMinuteContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, RFC5322ParserRULE_minute)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(520)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 60, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(510)
			p.Match(RFC5322ParserDigit)
		}
		{
			p.SetState(511)
			p.Match(RFC5322ParserDigit)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(513)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RFC5322ParserTAB)|(1<<RFC5322ParserCR)|(1<<RFC5322ParserSP)|(1<<RFC5322ParserLParens))) != 0 {
			{
				p.SetState(512)
				p.Cfws()
			}

		}
		{
			p.SetState(515)
			p.Match(RFC5322ParserDigit)
		}
		{
			p.SetState(516)
			p.Match(RFC5322ParserDigit)
		}
		p.SetState(518)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 59, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(517)
				p.Cfws()
			}

		}

	}

	return localctx
}

// ISecondContext is an interface to support dynamic dispatch.
type ISecondContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSecondContext differentiates from other interfaces.
	IsSecondContext()
}

type SecondContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySecondContext() *SecondContext {
	var p = new(SecondContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFC5322ParserRULE_second
	return p
}

func (*SecondContext) IsSecondContext() {}

func NewSecondContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SecondContext {
	var p = new(SecondContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC5322ParserRULE_second

	return p
}

func (s *SecondContext) GetParser() antlr.Parser { return s.parser }

func (s *SecondContext) AllDigit() []antlr.TerminalNode {
	return s.GetTokens(RFC5322ParserDigit)
}

func (s *SecondContext) Digit(i int) antlr.TerminalNode {
	return s.GetToken(RFC5322ParserDigit, i)
}

func (s *SecondContext) AllCfws() []ICfwsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICfwsContext); ok {
			len++
		}
	}

	tst := make([]ICfwsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICfwsContext); ok {
			tst[i] = t.(ICfwsContext)
			i++
		}
	}

	return tst
}

func (s *SecondContext) Cfws(i int) ICfwsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICfwsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICfwsContext)
}

func (s *SecondContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SecondContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SecondContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.EnterSecond(s)
	}
}

func (s *SecondContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.ExitSecond(s)
	}
}

func (p *RFC5322Parser) Second() (localctx ISecondContext) {
	this := p
	_ = this

	localctx = NewSecondContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, RFC5322ParserRULE_second)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(532)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 63, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(522)
			p.Match(RFC5322ParserDigit)
		}
		{
			p.SetState(523)
			p.Match(RFC5322ParserDigit)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(525)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RFC5322ParserTAB)|(1<<RFC5322ParserCR)|(1<<RFC5322ParserSP)|(1<<RFC5322ParserLParens))) != 0 {
			{
				p.SetState(524)
				p.Cfws()
			}

		}
		{
			p.SetState(527)
			p.Match(RFC5322ParserDigit)
		}
		{
			p.SetState(528)
			p.Match(RFC5322ParserDigit)
		}
		p.SetState(530)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 62, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(529)
				p.Cfws()
			}

		}

	}

	return localctx
}

// IOffsetContext is an interface to support dynamic dispatch.
type IOffsetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOffsetContext differentiates from other interfaces.
	IsOffsetContext()
}

type OffsetContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOffsetContext() *OffsetContext {
	var p = new(OffsetContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFC5322ParserRULE_offset
	return p
}

func (*OffsetContext) IsOffsetContext() {}

func NewOffsetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OffsetContext {
	var p = new(OffsetContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC5322ParserRULE_offset

	return p
}

func (s *OffsetContext) GetParser() antlr.Parser { return s.parser }

func (s *OffsetContext) AllDigit() []antlr.TerminalNode {
	return s.GetTokens(RFC5322ParserDigit)
}

func (s *OffsetContext) Digit(i int) antlr.TerminalNode {
	return s.GetToken(RFC5322ParserDigit, i)
}

func (s *OffsetContext) Plus() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserPlus, 0)
}

func (s *OffsetContext) Minus() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserMinus, 0)
}

func (s *OffsetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OffsetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OffsetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.EnterOffset(s)
	}
}

func (s *OffsetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.ExitOffset(s)
	}
}

func (p *RFC5322Parser) Offset() (localctx IOffsetContext) {
	this := p
	_ = this

	localctx = NewOffsetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, RFC5322ParserRULE_offset)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(535)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == RFC5322ParserPlus || _la == RFC5322ParserMinus {
		{
			p.SetState(534)
			_la = p.GetTokenStream().LA(1)

			if !(_la == RFC5322ParserPlus || _la == RFC5322ParserMinus) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(537)
		p.Match(RFC5322ParserDigit)
	}
	{
		p.SetState(538)
		p.Match(RFC5322ParserDigit)
	}
	{
		p.SetState(539)
		p.Match(RFC5322ParserDigit)
	}
	{
		p.SetState(540)
		p.Match(RFC5322ParserDigit)
	}

	return localctx
}

// IZoneContext is an interface to support dynamic dispatch.
type IZoneContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsZoneContext differentiates from other interfaces.
	IsZoneContext()
}

type ZoneContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyZoneContext() *ZoneContext {
	var p = new(ZoneContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFC5322ParserRULE_zone
	return p
}

func (*ZoneContext) IsZoneContext() {}

func NewZoneContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ZoneContext {
	var p = new(ZoneContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC5322ParserRULE_zone

	return p
}

func (s *ZoneContext) GetParser() antlr.Parser { return s.parser }

func (s *ZoneContext) Fws() IFwsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFwsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFwsContext)
}

func (s *ZoneContext) Offset() IOffsetContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOffsetContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOffsetContext)
}

func (s *ZoneContext) ObsZone() IObsZoneContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObsZoneContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObsZoneContext)
}

func (s *ZoneContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ZoneContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ZoneContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.EnterZone(s)
	}
}

func (s *ZoneContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.ExitZone(s)
	}
}

func (p *RFC5322Parser) Zone() (localctx IZoneContext) {
	this := p
	_ = this

	localctx = NewZoneContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, RFC5322ParserRULE_zone)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(546)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case RFC5322ParserTAB, RFC5322ParserCR, RFC5322ParserSP:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(542)
			p.Fws()
		}
		{
			p.SetState(543)
			p.Offset()
		}

	case RFC5322ParserC, RFC5322ParserE, RFC5322ParserG, RFC5322ParserM, RFC5322ParserP, RFC5322ParserU:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(545)
			p.ObsZone()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IAddressContext is an interface to support dynamic dispatch.
type IAddressContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAddressContext differentiates from other interfaces.
	IsAddressContext()
}

type AddressContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAddressContext() *AddressContext {
	var p = new(AddressContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFC5322ParserRULE_address
	return p
}

func (*AddressContext) IsAddressContext() {}

func NewAddressContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AddressContext {
	var p = new(AddressContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC5322ParserRULE_address

	return p
}

func (s *AddressContext) GetParser() antlr.Parser { return s.parser }

func (s *AddressContext) Mailbox() IMailboxContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMailboxContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMailboxContext)
}

func (s *AddressContext) Group() IGroupContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGroupContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGroupContext)
}

func (s *AddressContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddressContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AddressContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.EnterAddress(s)
	}
}

func (s *AddressContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.ExitAddress(s)
	}
}

func (p *RFC5322Parser) Address() (localctx IAddressContext) {
	this := p
	_ = this

	localctx = NewAddressContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, RFC5322ParserRULE_address)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(550)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 66, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(548)
			p.Mailbox()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(549)
			p.Group()
		}

	}

	return localctx
}

// IMailboxContext is an interface to support dynamic dispatch.
type IMailboxContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMailboxContext differentiates from other interfaces.
	IsMailboxContext()
}

type MailboxContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMailboxContext() *MailboxContext {
	var p = new(MailboxContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFC5322ParserRULE_mailbox
	return p
}

func (*MailboxContext) IsMailboxContext() {}

func NewMailboxContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MailboxContext {
	var p = new(MailboxContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC5322ParserRULE_mailbox

	return p
}

func (s *MailboxContext) GetParser() antlr.Parser { return s.parser }

func (s *MailboxContext) NameAddr() INameAddrContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameAddrContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameAddrContext)
}

func (s *MailboxContext) AddrSpec() IAddrSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAddrSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAddrSpecContext)
}

func (s *MailboxContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MailboxContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MailboxContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.EnterMailbox(s)
	}
}

func (s *MailboxContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.ExitMailbox(s)
	}
}

func (p *RFC5322Parser) Mailbox() (localctx IMailboxContext) {
	this := p
	_ = this

	localctx = NewMailboxContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, RFC5322ParserRULE_mailbox)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(554)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 67, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(552)
			p.NameAddr()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(553)
			p.AddrSpec()
		}

	}

	return localctx
}

// INameAddrContext is an interface to support dynamic dispatch.
type INameAddrContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNameAddrContext differentiates from other interfaces.
	IsNameAddrContext()
}

type NameAddrContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNameAddrContext() *NameAddrContext {
	var p = new(NameAddrContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFC5322ParserRULE_nameAddr
	return p
}

func (*NameAddrContext) IsNameAddrContext() {}

func NewNameAddrContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NameAddrContext {
	var p = new(NameAddrContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC5322ParserRULE_nameAddr

	return p
}

func (s *NameAddrContext) GetParser() antlr.Parser { return s.parser }

func (s *NameAddrContext) AngleAddr() IAngleAddrContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAngleAddrContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAngleAddrContext)
}

func (s *NameAddrContext) DisplayName() IDisplayNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDisplayNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDisplayNameContext)
}

func (s *NameAddrContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NameAddrContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NameAddrContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.EnterNameAddr(s)
	}
}

func (s *NameAddrContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.ExitNameAddr(s)
	}
}

func (p *RFC5322Parser) NameAddr() (localctx INameAddrContext) {
	this := p
	_ = this

	localctx = NewNameAddrContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, RFC5322ParserRULE_nameAddr)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(557)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 68, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(556)
			p.DisplayName()
		}

	}
	{
		p.SetState(559)
		p.AngleAddr()
	}

	return localctx
}

// IAngleAddrContext is an interface to support dynamic dispatch.
type IAngleAddrContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAngleAddrContext differentiates from other interfaces.
	IsAngleAddrContext()
}

type AngleAddrContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAngleAddrContext() *AngleAddrContext {
	var p = new(AngleAddrContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFC5322ParserRULE_angleAddr
	return p
}

func (*AngleAddrContext) IsAngleAddrContext() {}

func NewAngleAddrContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AngleAddrContext {
	var p = new(AngleAddrContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC5322ParserRULE_angleAddr

	return p
}

func (s *AngleAddrContext) GetParser() antlr.Parser { return s.parser }

func (s *AngleAddrContext) Less() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserLess, 0)
}

func (s *AngleAddrContext) Greater() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserGreater, 0)
}

func (s *AngleAddrContext) AllCfws() []ICfwsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICfwsContext); ok {
			len++
		}
	}

	tst := make([]ICfwsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICfwsContext); ok {
			tst[i] = t.(ICfwsContext)
			i++
		}
	}

	return tst
}

func (s *AngleAddrContext) Cfws(i int) ICfwsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICfwsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICfwsContext)
}

func (s *AngleAddrContext) AddrSpec() IAddrSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAddrSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAddrSpecContext)
}

func (s *AngleAddrContext) ObsAngleAddr() IObsAngleAddrContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObsAngleAddrContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObsAngleAddrContext)
}

func (s *AngleAddrContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AngleAddrContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AngleAddrContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.EnterAngleAddr(s)
	}
}

func (s *AngleAddrContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.ExitAngleAddr(s)
	}
}

func (p *RFC5322Parser) AngleAddr() (localctx IAngleAddrContext) {
	this := p
	_ = this

	localctx = NewAngleAddrContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, RFC5322ParserRULE_angleAddr)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(573)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 72, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(562)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RFC5322ParserTAB)|(1<<RFC5322ParserCR)|(1<<RFC5322ParserSP)|(1<<RFC5322ParserLParens))) != 0 {
			{
				p.SetState(561)
				p.Cfws()
			}

		}
		{
			p.SetState(564)
			p.Match(RFC5322ParserLess)
		}
		p.SetState(566)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RFC5322ParserTAB)|(1<<RFC5322ParserCR)|(1<<RFC5322ParserSP)|(1<<RFC5322ParserExclamation)|(1<<RFC5322ParserDQuote)|(1<<RFC5322ParserHash)|(1<<RFC5322ParserDollar)|(1<<RFC5322ParserPercent)|(1<<RFC5322ParserAmpersand)|(1<<RFC5322ParserSQuote)|(1<<RFC5322ParserLParens)|(1<<RFC5322ParserAsterisk)|(1<<RFC5322ParserPlus)|(1<<RFC5322ParserMinus)|(1<<RFC5322ParserSlash)|(1<<RFC5322ParserDigit)|(1<<RFC5322ParserEqual)|(1<<RFC5322ParserQuestion))) != 0) || (((_la-36)&-(0x1f+1)) == 0 && ((1<<uint((_la-36)))&((1<<(RFC5322ParserCaret-36))|(1<<(RFC5322ParserUnderscore-36))|(1<<(RFC5322ParserBacktick-36))|(1<<(RFC5322ParserLCurly-36))|(1<<(RFC5322ParserPipe-36))|(1<<(RFC5322ParserRCurly-36))|(1<<(RFC5322ParserTilde-36))|(1<<(RFC5322ParserUTF8NonAscii-36))|(1<<(RFC5322ParserA-36))|(1<<(RFC5322ParserB-36))|(1<<(RFC5322ParserC-36))|(1<<(RFC5322ParserD-36))|(1<<(RFC5322ParserE-36))|(1<<(RFC5322ParserF-36))|(1<<(RFC5322ParserG-36))|(1<<(RFC5322ParserH-36))|(1<<(RFC5322ParserI-36))|(1<<(RFC5322ParserJ-36))|(1<<(RFC5322ParserK-36))|(1<<(RFC5322ParserL-36))|(1<<(RFC5322ParserM-36))|(1<<(RFC5322ParserN-36))|(1<<(RFC5322ParserO-36))|(1<<(RFC5322ParserP-36))|(1<<(RFC5322ParserQ-36))|(1<<(RFC5322ParserR-36))|(1<<(RFC5322ParserS-36))|(1<<(RFC5322ParserT-36))|(1<<(RFC5322ParserU-36))|(1<<(RFC5322ParserV-36))|(1<<(RFC5322ParserW-36)))) != 0) || (((_la-68)&-(0x1f+1)) == 0 && ((1<<uint((_la-68)))&((1<<(RFC5322ParserX-68))|(1<<(RFC5322ParserY-68))|(1<<(RFC5322ParserZ-68)))) != 0) {
			{
				p.SetState(565)
				p.AddrSpec()
			}

		}
		{
			p.SetState(568)
			p.Match(RFC5322ParserGreater)
		}
		p.SetState(570)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 71, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(569)
				p.Cfws()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(572)
			p.ObsAngleAddr()
		}

	}

	return localctx
}

// IGroupContext is an interface to support dynamic dispatch.
type IGroupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGroupContext differentiates from other interfaces.
	IsGroupContext()
}

type GroupContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGroupContext() *GroupContext {
	var p = new(GroupContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFC5322ParserRULE_group
	return p
}

func (*GroupContext) IsGroupContext() {}

func NewGroupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GroupContext {
	var p = new(GroupContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC5322ParserRULE_group

	return p
}

func (s *GroupContext) GetParser() antlr.Parser { return s.parser }

func (s *GroupContext) DisplayName() IDisplayNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDisplayNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDisplayNameContext)
}

func (s *GroupContext) Colon() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserColon, 0)
}

func (s *GroupContext) AllDQuote() []antlr.TerminalNode {
	return s.GetTokens(RFC5322ParserDQuote)
}

func (s *GroupContext) DQuote(i int) antlr.TerminalNode {
	return s.GetToken(RFC5322ParserDQuote, i)
}

func (s *GroupContext) GroupList() IGroupListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGroupListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGroupListContext)
}

func (s *GroupContext) Semicolon() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserSemicolon, 0)
}

func (s *GroupContext) Cfws() ICfwsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICfwsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICfwsContext)
}

func (s *GroupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GroupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GroupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.EnterGroup(s)
	}
}

func (s *GroupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.ExitGroup(s)
	}
}

func (p *RFC5322Parser) Group() (localctx IGroupContext) {
	this := p
	_ = this

	localctx = NewGroupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, RFC5322ParserRULE_group)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(576)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 73, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(575)
			p.Match(RFC5322ParserDQuote)
		}

	}
	{
		p.SetState(578)
		p.DisplayName()
	}
	{
		p.SetState(579)
		p.Match(RFC5322ParserColon)
	}
	p.SetState(581)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 74, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(580)
			p.GroupList()
		}

	}
	p.SetState(584)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == RFC5322ParserDQuote {
		{
			p.SetState(583)
			p.Match(RFC5322ParserDQuote)
		}

	}
	p.SetState(587)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 76, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(586)
			p.Match(RFC5322ParserSemicolon)
		}

	}
	p.SetState(590)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RFC5322ParserTAB)|(1<<RFC5322ParserCR)|(1<<RFC5322ParserSP)|(1<<RFC5322ParserLParens))) != 0 {
		{
			p.SetState(589)
			p.Cfws()
		}

	}

	return localctx
}

// IUnspacedContext is an interface to support dynamic dispatch.
type IUnspacedContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnspacedContext differentiates from other interfaces.
	IsUnspacedContext()
}

type UnspacedContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnspacedContext() *UnspacedContext {
	var p = new(UnspacedContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFC5322ParserRULE_unspaced
	return p
}

func (*UnspacedContext) IsUnspacedContext() {}

func NewUnspacedContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnspacedContext {
	var p = new(UnspacedContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC5322ParserRULE_unspaced

	return p
}

func (s *UnspacedContext) GetParser() antlr.Parser { return s.parser }

func (s *UnspacedContext) Period() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserPeriod, 0)
}

func (s *UnspacedContext) At() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserAt, 0)
}

func (s *UnspacedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnspacedContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnspacedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.EnterUnspaced(s)
	}
}

func (s *UnspacedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.ExitUnspaced(s)
	}
}

func (p *RFC5322Parser) Unspaced() (localctx IUnspacedContext) {
	this := p
	_ = this

	localctx = NewUnspacedContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, RFC5322ParserRULE_unspaced)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(592)
		_la = p.GetTokenStream().LA(1)

		if !(_la == RFC5322ParserPeriod || _la == RFC5322ParserAt) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IDisplayNameContext is an interface to support dynamic dispatch.
type IDisplayNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDisplayNameContext differentiates from other interfaces.
	IsDisplayNameContext()
}

type DisplayNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDisplayNameContext() *DisplayNameContext {
	var p = new(DisplayNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFC5322ParserRULE_displayName
	return p
}

func (*DisplayNameContext) IsDisplayNameContext() {}

func NewDisplayNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DisplayNameContext {
	var p = new(DisplayNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC5322ParserRULE_displayName

	return p
}

func (s *DisplayNameContext) GetParser() antlr.Parser { return s.parser }

func (s *DisplayNameContext) AllWord() []IWordContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IWordContext); ok {
			len++
		}
	}

	tst := make([]IWordContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IWordContext); ok {
			tst[i] = t.(IWordContext)
			i++
		}
	}

	return tst
}

func (s *DisplayNameContext) Word(i int) IWordContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWordContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWordContext)
}

func (s *DisplayNameContext) AllUnspaced() []IUnspacedContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUnspacedContext); ok {
			len++
		}
	}

	tst := make([]IUnspacedContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUnspacedContext); ok {
			tst[i] = t.(IUnspacedContext)
			i++
		}
	}

	return tst
}

func (s *DisplayNameContext) Unspaced(i int) IUnspacedContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnspacedContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnspacedContext)
}

func (s *DisplayNameContext) AllCfws() []ICfwsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICfwsContext); ok {
			len++
		}
	}

	tst := make([]ICfwsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICfwsContext); ok {
			tst[i] = t.(ICfwsContext)
			i++
		}
	}

	return tst
}

func (s *DisplayNameContext) Cfws(i int) ICfwsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICfwsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICfwsContext)
}

func (s *DisplayNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DisplayNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DisplayNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.EnterDisplayName(s)
	}
}

func (s *DisplayNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.ExitDisplayName(s)
	}
}

func (p *RFC5322Parser) DisplayName() (localctx IDisplayNameContext) {
	this := p
	_ = this

	localctx = NewDisplayNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, RFC5322ParserRULE_displayName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(608)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 81, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(595)
		p.GetErrorHandler().Sync(p)
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(594)
					p.Word()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(597)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 78, p.GetParserRuleContext())
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(599)
			p.Word()
		}
		p.SetState(605)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 80, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				p.SetState(603)
				p.GetErrorHandler().Sync(p)
				switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 79, p.GetParserRuleContext()) {
				case 1:
					{
						p.SetState(600)
						p.Word()
					}

				case 2:
					{
						p.SetState(601)
						p.Unspaced()
					}

				case 3:
					{
						p.SetState(602)
						p.Cfws()
					}

				}

			}
			p.SetState(607)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 80, p.GetParserRuleContext())
		}

	}

	return localctx
}

// IMailboxListContext is an interface to support dynamic dispatch.
type IMailboxListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMailboxListContext differentiates from other interfaces.
	IsMailboxListContext()
}

type MailboxListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMailboxListContext() *MailboxListContext {
	var p = new(MailboxListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFC5322ParserRULE_mailboxList
	return p
}

func (*MailboxListContext) IsMailboxListContext() {}

func NewMailboxListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MailboxListContext {
	var p = new(MailboxListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC5322ParserRULE_mailboxList

	return p
}

func (s *MailboxListContext) GetParser() antlr.Parser { return s.parser }

func (s *MailboxListContext) AllMailbox() []IMailboxContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMailboxContext); ok {
			len++
		}
	}

	tst := make([]IMailboxContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMailboxContext); ok {
			tst[i] = t.(IMailboxContext)
			i++
		}
	}

	return tst
}

func (s *MailboxListContext) Mailbox(i int) IMailboxContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMailboxContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMailboxContext)
}

func (s *MailboxListContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(RFC5322ParserComma)
}

func (s *MailboxListContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(RFC5322ParserComma, i)
}

func (s *MailboxListContext) ObsMboxList() IObsMboxListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObsMboxListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObsMboxListContext)
}

func (s *MailboxListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MailboxListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MailboxListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.EnterMailboxList(s)
	}
}

func (s *MailboxListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.ExitMailboxList(s)
	}
}

func (p *RFC5322Parser) MailboxList() (localctx IMailboxListContext) {
	this := p
	_ = this

	localctx = NewMailboxListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, RFC5322ParserRULE_mailboxList)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(619)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 83, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(610)
			p.Mailbox()
		}
		p.SetState(615)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 82, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(611)
					p.Match(RFC5322ParserComma)
				}
				{
					p.SetState(612)
					p.Mailbox()
				}

			}
			p.SetState(617)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 82, p.GetParserRuleContext())
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(618)
			p.ObsMboxList()
		}

	}

	return localctx
}

// IAddressListContext is an interface to support dynamic dispatch.
type IAddressListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAddressListContext differentiates from other interfaces.
	IsAddressListContext()
}

type AddressListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAddressListContext() *AddressListContext {
	var p = new(AddressListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFC5322ParserRULE_addressList
	return p
}

func (*AddressListContext) IsAddressListContext() {}

func NewAddressListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AddressListContext {
	var p = new(AddressListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC5322ParserRULE_addressList

	return p
}

func (s *AddressListContext) GetParser() antlr.Parser { return s.parser }

func (s *AddressListContext) AllAddress() []IAddressContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAddressContext); ok {
			len++
		}
	}

	tst := make([]IAddressContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAddressContext); ok {
			tst[i] = t.(IAddressContext)
			i++
		}
	}

	return tst
}

func (s *AddressListContext) Address(i int) IAddressContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAddressContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAddressContext)
}

func (s *AddressListContext) EOF() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserEOF, 0)
}

func (s *AddressListContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(RFC5322ParserComma)
}

func (s *AddressListContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(RFC5322ParserComma, i)
}

func (s *AddressListContext) AllSemicolon() []antlr.TerminalNode {
	return s.GetTokens(RFC5322ParserSemicolon)
}

func (s *AddressListContext) Semicolon(i int) antlr.TerminalNode {
	return s.GetToken(RFC5322ParserSemicolon, i)
}

func (s *AddressListContext) ObsAddrList() IObsAddrListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObsAddrListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObsAddrListContext)
}

func (s *AddressListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddressListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AddressListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.EnterAddressList(s)
	}
}

func (s *AddressListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.ExitAddressList(s)
	}
}

func (p *RFC5322Parser) AddressList() (localctx IAddressListContext) {
	this := p
	_ = this

	localctx = NewAddressListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, RFC5322ParserRULE_addressList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(634)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 85, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(621)
			p.Address()
		}
		p.SetState(626)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == RFC5322ParserComma || _la == RFC5322ParserSemicolon {
			{
				p.SetState(622)
				_la = p.GetTokenStream().LA(1)

				if !(_la == RFC5322ParserComma || _la == RFC5322ParserSemicolon) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(623)
				p.Address()
			}

			p.SetState(628)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(629)
			p.Match(RFC5322ParserEOF)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(631)
			p.ObsAddrList()
		}
		{
			p.SetState(632)
			p.Match(RFC5322ParserEOF)
		}

	}

	return localctx
}

// IGroupListContext is an interface to support dynamic dispatch.
type IGroupListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGroupListContext differentiates from other interfaces.
	IsGroupListContext()
}

type GroupListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGroupListContext() *GroupListContext {
	var p = new(GroupListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFC5322ParserRULE_groupList
	return p
}

func (*GroupListContext) IsGroupListContext() {}

func NewGroupListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GroupListContext {
	var p = new(GroupListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC5322ParserRULE_groupList

	return p
}

func (s *GroupListContext) GetParser() antlr.Parser { return s.parser }

func (s *GroupListContext) MailboxList() IMailboxListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMailboxListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMailboxListContext)
}

func (s *GroupListContext) Cfws() ICfwsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICfwsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICfwsContext)
}

func (s *GroupListContext) ObsGroupList() IObsGroupListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObsGroupListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObsGroupListContext)
}

func (s *GroupListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GroupListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GroupListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.EnterGroupList(s)
	}
}

func (s *GroupListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.ExitGroupList(s)
	}
}

func (p *RFC5322Parser) GroupList() (localctx IGroupListContext) {
	this := p
	_ = this

	localctx = NewGroupListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, RFC5322ParserRULE_groupList)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(639)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 86, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(636)
			p.MailboxList()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(637)
			p.Cfws()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(638)
			p.ObsGroupList()
		}

	}

	return localctx
}

// IAddrSpecContext is an interface to support dynamic dispatch.
type IAddrSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAddrSpecContext differentiates from other interfaces.
	IsAddrSpecContext()
}

type AddrSpecContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAddrSpecContext() *AddrSpecContext {
	var p = new(AddrSpecContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFC5322ParserRULE_addrSpec
	return p
}

func (*AddrSpecContext) IsAddrSpecContext() {}

func NewAddrSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AddrSpecContext {
	var p = new(AddrSpecContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC5322ParserRULE_addrSpec

	return p
}

func (s *AddrSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *AddrSpecContext) LocalPart() ILocalPartContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILocalPartContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILocalPartContext)
}

func (s *AddrSpecContext) At() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserAt, 0)
}

func (s *AddrSpecContext) Domain() IDomainContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDomainContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDomainContext)
}

func (s *AddrSpecContext) Colon() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserColon, 0)
}

func (s *AddrSpecContext) Port() IPortContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPortContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPortContext)
}

func (s *AddrSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddrSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AddrSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.EnterAddrSpec(s)
	}
}

func (s *AddrSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.ExitAddrSpec(s)
	}
}

func (p *RFC5322Parser) AddrSpec() (localctx IAddrSpecContext) {
	this := p
	_ = this

	localctx = NewAddrSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, RFC5322ParserRULE_addrSpec)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(641)
		p.LocalPart()
	}
	{
		p.SetState(642)
		p.Match(RFC5322ParserAt)
	}
	{
		p.SetState(643)
		p.Domain()
	}
	p.SetState(646)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == RFC5322ParserColon {
		{
			p.SetState(644)
			p.Match(RFC5322ParserColon)
		}
		{
			p.SetState(645)
			p.Port()
		}

	}

	return localctx
}

// ILocalPartContext is an interface to support dynamic dispatch.
type ILocalPartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLocalPartContext differentiates from other interfaces.
	IsLocalPartContext()
}

type LocalPartContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLocalPartContext() *LocalPartContext {
	var p = new(LocalPartContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFC5322ParserRULE_localPart
	return p
}

func (*LocalPartContext) IsLocalPartContext() {}

func NewLocalPartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LocalPartContext {
	var p = new(LocalPartContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC5322ParserRULE_localPart

	return p
}

func (s *LocalPartContext) GetParser() antlr.Parser { return s.parser }

func (s *LocalPartContext) DotAtom() IDotAtomContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDotAtomContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDotAtomContext)
}

func (s *LocalPartContext) AllCfws() []ICfwsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICfwsContext); ok {
			len++
		}
	}

	tst := make([]ICfwsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICfwsContext); ok {
			tst[i] = t.(ICfwsContext)
			i++
		}
	}

	return tst
}

func (s *LocalPartContext) Cfws(i int) ICfwsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICfwsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICfwsContext)
}

func (s *LocalPartContext) QuotedString() IQuotedStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQuotedStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQuotedStringContext)
}

func (s *LocalPartContext) ObsLocalPart() IObsLocalPartContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObsLocalPartContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObsLocalPartContext)
}

func (s *LocalPartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LocalPartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LocalPartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.EnterLocalPart(s)
	}
}

func (s *LocalPartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.ExitLocalPart(s)
	}
}

func (p *RFC5322Parser) LocalPart() (localctx ILocalPartContext) {
	this := p
	_ = this

	localctx = NewLocalPartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, RFC5322ParserRULE_localPart)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(663)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 92, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(649)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RFC5322ParserTAB)|(1<<RFC5322ParserCR)|(1<<RFC5322ParserSP)|(1<<RFC5322ParserLParens))) != 0 {
			{
				p.SetState(648)
				p.Cfws()
			}

		}
		{
			p.SetState(651)
			p.DotAtom()
		}
		p.SetState(653)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RFC5322ParserTAB)|(1<<RFC5322ParserCR)|(1<<RFC5322ParserSP)|(1<<RFC5322ParserLParens))) != 0 {
			{
				p.SetState(652)
				p.Cfws()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(656)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RFC5322ParserTAB)|(1<<RFC5322ParserCR)|(1<<RFC5322ParserSP)|(1<<RFC5322ParserLParens))) != 0 {
			{
				p.SetState(655)
				p.Cfws()
			}

		}
		{
			p.SetState(658)
			p.QuotedString()
		}
		p.SetState(660)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RFC5322ParserTAB)|(1<<RFC5322ParserCR)|(1<<RFC5322ParserSP)|(1<<RFC5322ParserLParens))) != 0 {
			{
				p.SetState(659)
				p.Cfws()
			}

		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(662)
			p.ObsLocalPart()
		}

	}

	return localctx
}

// IPortContext is an interface to support dynamic dispatch.
type IPortContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPortContext differentiates from other interfaces.
	IsPortContext()
}

type PortContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPortContext() *PortContext {
	var p = new(PortContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFC5322ParserRULE_port
	return p
}

func (*PortContext) IsPortContext() {}

func NewPortContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PortContext {
	var p = new(PortContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC5322ParserRULE_port

	return p
}

func (s *PortContext) GetParser() antlr.Parser { return s.parser }

func (s *PortContext) AllDigit() []antlr.TerminalNode {
	return s.GetTokens(RFC5322ParserDigit)
}

func (s *PortContext) Digit(i int) antlr.TerminalNode {
	return s.GetToken(RFC5322ParserDigit, i)
}

func (s *PortContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PortContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PortContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.EnterPort(s)
	}
}

func (s *PortContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.ExitPort(s)
	}
}

func (p *RFC5322Parser) Port() (localctx IPortContext) {
	this := p
	_ = this

	localctx = NewPortContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, RFC5322ParserRULE_port)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(666)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == RFC5322ParserDigit {
		{
			p.SetState(665)
			p.Match(RFC5322ParserDigit)
		}

		p.SetState(668)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IDomainContext is an interface to support dynamic dispatch.
type IDomainContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDomainContext differentiates from other interfaces.
	IsDomainContext()
}

type DomainContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDomainContext() *DomainContext {
	var p = new(DomainContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFC5322ParserRULE_domain
	return p
}

func (*DomainContext) IsDomainContext() {}

func NewDomainContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DomainContext {
	var p = new(DomainContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC5322ParserRULE_domain

	return p
}

func (s *DomainContext) GetParser() antlr.Parser { return s.parser }

func (s *DomainContext) DotAtom() IDotAtomContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDotAtomContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDotAtomContext)
}

func (s *DomainContext) AllCfws() []ICfwsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICfwsContext); ok {
			len++
		}
	}

	tst := make([]ICfwsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICfwsContext); ok {
			tst[i] = t.(ICfwsContext)
			i++
		}
	}

	return tst
}

func (s *DomainContext) Cfws(i int) ICfwsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICfwsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICfwsContext)
}

func (s *DomainContext) DomainLiteral() IDomainLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDomainLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDomainLiteralContext)
}

func (s *DomainContext) ObsDomain() IObsDomainContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObsDomainContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObsDomainContext)
}

func (s *DomainContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DomainContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DomainContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.EnterDomain(s)
	}
}

func (s *DomainContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.ExitDomain(s)
	}
}

func (p *RFC5322Parser) Domain() (localctx IDomainContext) {
	this := p
	_ = this

	localctx = NewDomainContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, RFC5322ParserRULE_domain)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(691)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 100, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(671)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RFC5322ParserTAB)|(1<<RFC5322ParserCR)|(1<<RFC5322ParserSP)|(1<<RFC5322ParserLParens))) != 0 {
			{
				p.SetState(670)
				p.Cfws()
			}

		}
		{
			p.SetState(673)
			p.DotAtom()
		}
		p.SetState(675)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 95, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(674)
				p.Cfws()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(678)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RFC5322ParserTAB)|(1<<RFC5322ParserCR)|(1<<RFC5322ParserSP)|(1<<RFC5322ParserLParens))) != 0 {
			{
				p.SetState(677)
				p.Cfws()
			}

		}
		{
			p.SetState(680)
			p.DomainLiteral()
		}
		p.SetState(682)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 97, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(681)
				p.Cfws()
			}

		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(685)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RFC5322ParserTAB)|(1<<RFC5322ParserCR)|(1<<RFC5322ParserSP)|(1<<RFC5322ParserLParens))) != 0 {
			{
				p.SetState(684)
				p.Cfws()
			}

		}
		{
			p.SetState(687)
			p.ObsDomain()
		}
		p.SetState(689)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 99, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(688)
				p.Cfws()
			}

		}

	}

	return localctx
}

// IDomainLiteralContext is an interface to support dynamic dispatch.
type IDomainLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDomainLiteralContext differentiates from other interfaces.
	IsDomainLiteralContext()
}

type DomainLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDomainLiteralContext() *DomainLiteralContext {
	var p = new(DomainLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFC5322ParserRULE_domainLiteral
	return p
}

func (*DomainLiteralContext) IsDomainLiteralContext() {}

func NewDomainLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DomainLiteralContext {
	var p = new(DomainLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC5322ParserRULE_domainLiteral

	return p
}

func (s *DomainLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *DomainLiteralContext) LBracket() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserLBracket, 0)
}

func (s *DomainLiteralContext) RBracket() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserRBracket, 0)
}

func (s *DomainLiteralContext) AllDtext() []IDtextContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDtextContext); ok {
			len++
		}
	}

	tst := make([]IDtextContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDtextContext); ok {
			tst[i] = t.(IDtextContext)
			i++
		}
	}

	return tst
}

func (s *DomainLiteralContext) Dtext(i int) IDtextContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDtextContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDtextContext)
}

func (s *DomainLiteralContext) AllFws() []IFwsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFwsContext); ok {
			len++
		}
	}

	tst := make([]IFwsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFwsContext); ok {
			tst[i] = t.(IFwsContext)
			i++
		}
	}

	return tst
}

func (s *DomainLiteralContext) Fws(i int) IFwsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFwsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFwsContext)
}

func (s *DomainLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DomainLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DomainLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.EnterDomainLiteral(s)
	}
}

func (s *DomainLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.ExitDomainLiteral(s)
	}
}

func (p *RFC5322Parser) DomainLiteral() (localctx IDomainLiteralContext) {
	this := p
	_ = this

	localctx = NewDomainLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, RFC5322ParserRULE_domainLiteral)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(693)
		p.Match(RFC5322ParserLBracket)
	}
	p.SetState(700)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 102, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(695)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RFC5322ParserTAB)|(1<<RFC5322ParserCR)|(1<<RFC5322ParserSP))) != 0 {
				{
					p.SetState(694)
					p.Fws()
				}

			}
			{
				p.SetState(697)
				p.Dtext()
			}

		}
		p.SetState(702)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 102, p.GetParserRuleContext())
	}
	p.SetState(704)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RFC5322ParserTAB)|(1<<RFC5322ParserCR)|(1<<RFC5322ParserSP))) != 0 {
		{
			p.SetState(703)
			p.Fws()
		}

	}
	{
		p.SetState(706)
		p.Match(RFC5322ParserRBracket)
	}

	return localctx
}

// IDtextContext is an interface to support dynamic dispatch.
type IDtextContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDtextContext differentiates from other interfaces.
	IsDtextContext()
}

type DtextContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDtextContext() *DtextContext {
	var p = new(DtextContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFC5322ParserRULE_dtext
	return p
}

func (*DtextContext) IsDtextContext() {}

func NewDtextContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DtextContext {
	var p = new(DtextContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC5322ParserRULE_dtext

	return p
}

func (s *DtextContext) GetParser() antlr.Parser { return s.parser }

func (s *DtextContext) Alpha() IAlphaContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlphaContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlphaContext)
}

func (s *DtextContext) Exclamation() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserExclamation, 0)
}

func (s *DtextContext) DQuote() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserDQuote, 0)
}

func (s *DtextContext) Hash() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserHash, 0)
}

func (s *DtextContext) Dollar() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserDollar, 0)
}

func (s *DtextContext) Percent() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserPercent, 0)
}

func (s *DtextContext) Ampersand() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserAmpersand, 0)
}

func (s *DtextContext) SQuote() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserSQuote, 0)
}

func (s *DtextContext) LParens() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserLParens, 0)
}

func (s *DtextContext) RParens() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserRParens, 0)
}

func (s *DtextContext) Asterisk() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserAsterisk, 0)
}

func (s *DtextContext) Plus() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserPlus, 0)
}

func (s *DtextContext) Comma() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserComma, 0)
}

func (s *DtextContext) Minus() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserMinus, 0)
}

func (s *DtextContext) Period() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserPeriod, 0)
}

func (s *DtextContext) Slash() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserSlash, 0)
}

func (s *DtextContext) Digit() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserDigit, 0)
}

func (s *DtextContext) Colon() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserColon, 0)
}

func (s *DtextContext) Semicolon() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserSemicolon, 0)
}

func (s *DtextContext) Less() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserLess, 0)
}

func (s *DtextContext) Equal() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserEqual, 0)
}

func (s *DtextContext) Greater() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserGreater, 0)
}

func (s *DtextContext) Question() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserQuestion, 0)
}

func (s *DtextContext) At() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserAt, 0)
}

func (s *DtextContext) Caret() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserCaret, 0)
}

func (s *DtextContext) Underscore() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserUnderscore, 0)
}

func (s *DtextContext) Backtick() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserBacktick, 0)
}

func (s *DtextContext) LCurly() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserLCurly, 0)
}

func (s *DtextContext) Pipe() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserPipe, 0)
}

func (s *DtextContext) RCurly() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserRCurly, 0)
}

func (s *DtextContext) Tilde() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserTilde, 0)
}

func (s *DtextContext) UTF8NonAscii() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserUTF8NonAscii, 0)
}

func (s *DtextContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DtextContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DtextContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.EnterDtext(s)
	}
}

func (s *DtextContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.ExitDtext(s)
	}
}

func (p *RFC5322Parser) Dtext() (localctx IDtextContext) {
	this := p
	_ = this

	localctx = NewDtextContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, RFC5322ParserRULE_dtext)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(740)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case RFC5322ParserA, RFC5322ParserB, RFC5322ParserC, RFC5322ParserD, RFC5322ParserE, RFC5322ParserF, RFC5322ParserG, RFC5322ParserH, RFC5322ParserI, RFC5322ParserJ, RFC5322ParserK, RFC5322ParserL, RFC5322ParserM, RFC5322ParserN, RFC5322ParserO, RFC5322ParserP, RFC5322ParserQ, RFC5322ParserR, RFC5322ParserS, RFC5322ParserT, RFC5322ParserU, RFC5322ParserV, RFC5322ParserW, RFC5322ParserX, RFC5322ParserY, RFC5322ParserZ:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(708)
			p.Alpha()
		}

	case RFC5322ParserExclamation:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(709)
			p.Match(RFC5322ParserExclamation)
		}

	case RFC5322ParserDQuote:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(710)
			p.Match(RFC5322ParserDQuote)
		}

	case RFC5322ParserHash:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(711)
			p.Match(RFC5322ParserHash)
		}

	case RFC5322ParserDollar:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(712)
			p.Match(RFC5322ParserDollar)
		}

	case RFC5322ParserPercent:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(713)
			p.Match(RFC5322ParserPercent)
		}

	case RFC5322ParserAmpersand:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(714)
			p.Match(RFC5322ParserAmpersand)
		}

	case RFC5322ParserSQuote:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(715)
			p.Match(RFC5322ParserSQuote)
		}

	case RFC5322ParserLParens:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(716)
			p.Match(RFC5322ParserLParens)
		}

	case RFC5322ParserRParens:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(717)
			p.Match(RFC5322ParserRParens)
		}

	case RFC5322ParserAsterisk:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(718)
			p.Match(RFC5322ParserAsterisk)
		}

	case RFC5322ParserPlus:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(719)
			p.Match(RFC5322ParserPlus)
		}

	case RFC5322ParserComma:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(720)
			p.Match(RFC5322ParserComma)
		}

	case RFC5322ParserMinus:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(721)
			p.Match(RFC5322ParserMinus)
		}

	case RFC5322ParserPeriod:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(722)
			p.Match(RFC5322ParserPeriod)
		}

	case RFC5322ParserSlash:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(723)
			p.Match(RFC5322ParserSlash)
		}

	case RFC5322ParserDigit:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(724)
			p.Match(RFC5322ParserDigit)
		}

	case RFC5322ParserColon:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(725)
			p.Match(RFC5322ParserColon)
		}

	case RFC5322ParserSemicolon:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(726)
			p.Match(RFC5322ParserSemicolon)
		}

	case RFC5322ParserLess:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(727)
			p.Match(RFC5322ParserLess)
		}

	case RFC5322ParserEqual:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(728)
			p.Match(RFC5322ParserEqual)
		}

	case RFC5322ParserGreater:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(729)
			p.Match(RFC5322ParserGreater)
		}

	case RFC5322ParserQuestion:
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(730)
			p.Match(RFC5322ParserQuestion)
		}

	case RFC5322ParserAt:
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(731)
			p.Match(RFC5322ParserAt)
		}

	case RFC5322ParserCaret:
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(732)
			p.Match(RFC5322ParserCaret)
		}

	case RFC5322ParserUnderscore:
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(733)
			p.Match(RFC5322ParserUnderscore)
		}

	case RFC5322ParserBacktick:
		p.EnterOuterAlt(localctx, 27)
		{
			p.SetState(734)
			p.Match(RFC5322ParserBacktick)
		}

	case RFC5322ParserLCurly:
		p.EnterOuterAlt(localctx, 28)
		{
			p.SetState(735)
			p.Match(RFC5322ParserLCurly)
		}

	case RFC5322ParserPipe:
		p.EnterOuterAlt(localctx, 29)
		{
			p.SetState(736)
			p.Match(RFC5322ParserPipe)
		}

	case RFC5322ParserRCurly:
		p.EnterOuterAlt(localctx, 30)
		{
			p.SetState(737)
			p.Match(RFC5322ParserRCurly)
		}

	case RFC5322ParserTilde:
		p.EnterOuterAlt(localctx, 31)
		{
			p.SetState(738)
			p.Match(RFC5322ParserTilde)
		}

	case RFC5322ParserUTF8NonAscii:
		p.EnterOuterAlt(localctx, 32)
		{
			p.SetState(739)
			p.Match(RFC5322ParserUTF8NonAscii)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IObsNoWSCTLContext is an interface to support dynamic dispatch.
type IObsNoWSCTLContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsObsNoWSCTLContext differentiates from other interfaces.
	IsObsNoWSCTLContext()
}

type ObsNoWSCTLContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObsNoWSCTLContext() *ObsNoWSCTLContext {
	var p = new(ObsNoWSCTLContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFC5322ParserRULE_obsNoWSCTL
	return p
}

func (*ObsNoWSCTLContext) IsObsNoWSCTLContext() {}

func NewObsNoWSCTLContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObsNoWSCTLContext {
	var p = new(ObsNoWSCTLContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC5322ParserRULE_obsNoWSCTL

	return p
}

func (s *ObsNoWSCTLContext) GetParser() antlr.Parser { return s.parser }

func (s *ObsNoWSCTLContext) U_01_08() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserU_01_08, 0)
}

func (s *ObsNoWSCTLContext) U_0B() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserU_0B, 0)
}

func (s *ObsNoWSCTLContext) U_0C() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserU_0C, 0)
}

func (s *ObsNoWSCTLContext) U_0E_1F() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserU_0E_1F, 0)
}

func (s *ObsNoWSCTLContext) Delete() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserDelete, 0)
}

func (s *ObsNoWSCTLContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObsNoWSCTLContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObsNoWSCTLContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.EnterObsNoWSCTL(s)
	}
}

func (s *ObsNoWSCTLContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.ExitObsNoWSCTL(s)
	}
}

func (p *RFC5322Parser) ObsNoWSCTL() (localctx IObsNoWSCTLContext) {
	this := p
	_ = this

	localctx = NewObsNoWSCTLContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, RFC5322ParserRULE_obsNoWSCTL)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(742)
		_la = p.GetTokenStream().LA(1)

		if !((((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RFC5322ParserU_01_08)|(1<<RFC5322ParserU_0B)|(1<<RFC5322ParserU_0C)|(1<<RFC5322ParserU_0E_1F))) != 0) || _la == RFC5322ParserDelete) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IObsCtextContext is an interface to support dynamic dispatch.
type IObsCtextContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsObsCtextContext differentiates from other interfaces.
	IsObsCtextContext()
}

type ObsCtextContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObsCtextContext() *ObsCtextContext {
	var p = new(ObsCtextContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFC5322ParserRULE_obsCtext
	return p
}

func (*ObsCtextContext) IsObsCtextContext() {}

func NewObsCtextContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObsCtextContext {
	var p = new(ObsCtextContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC5322ParserRULE_obsCtext

	return p
}

func (s *ObsCtextContext) GetParser() antlr.Parser { return s.parser }

func (s *ObsCtextContext) ObsNoWSCTL() IObsNoWSCTLContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObsNoWSCTLContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObsNoWSCTLContext)
}

func (s *ObsCtextContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObsCtextContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObsCtextContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.EnterObsCtext(s)
	}
}

func (s *ObsCtextContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.ExitObsCtext(s)
	}
}

func (p *RFC5322Parser) ObsCtext() (localctx IObsCtextContext) {
	this := p
	_ = this

	localctx = NewObsCtextContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, RFC5322ParserRULE_obsCtext)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(744)
		p.ObsNoWSCTL()
	}

	return localctx
}

// IObsQtextContext is an interface to support dynamic dispatch.
type IObsQtextContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsObsQtextContext differentiates from other interfaces.
	IsObsQtextContext()
}

type ObsQtextContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObsQtextContext() *ObsQtextContext {
	var p = new(ObsQtextContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFC5322ParserRULE_obsQtext
	return p
}

func (*ObsQtextContext) IsObsQtextContext() {}

func NewObsQtextContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObsQtextContext {
	var p = new(ObsQtextContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC5322ParserRULE_obsQtext

	return p
}

func (s *ObsQtextContext) GetParser() antlr.Parser { return s.parser }

func (s *ObsQtextContext) ObsNoWSCTL() IObsNoWSCTLContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObsNoWSCTLContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObsNoWSCTLContext)
}

func (s *ObsQtextContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObsQtextContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObsQtextContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.EnterObsQtext(s)
	}
}

func (s *ObsQtextContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.ExitObsQtext(s)
	}
}

func (p *RFC5322Parser) ObsQtext() (localctx IObsQtextContext) {
	this := p
	_ = this

	localctx = NewObsQtextContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, RFC5322ParserRULE_obsQtext)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(746)
		p.ObsNoWSCTL()
	}

	return localctx
}

// IObsQPContext is an interface to support dynamic dispatch.
type IObsQPContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsObsQPContext differentiates from other interfaces.
	IsObsQPContext()
}

type ObsQPContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObsQPContext() *ObsQPContext {
	var p = new(ObsQPContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFC5322ParserRULE_obsQP
	return p
}

func (*ObsQPContext) IsObsQPContext() {}

func NewObsQPContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObsQPContext {
	var p = new(ObsQPContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC5322ParserRULE_obsQP

	return p
}

func (s *ObsQPContext) GetParser() antlr.Parser { return s.parser }

func (s *ObsQPContext) Backslash() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserBackslash, 0)
}

func (s *ObsQPContext) U_00() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserU_00, 0)
}

func (s *ObsQPContext) ObsNoWSCTL() IObsNoWSCTLContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObsNoWSCTLContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObsNoWSCTLContext)
}

func (s *ObsQPContext) LF() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserLF, 0)
}

func (s *ObsQPContext) CR() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserCR, 0)
}

func (s *ObsQPContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObsQPContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObsQPContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.EnterObsQP(s)
	}
}

func (s *ObsQPContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.ExitObsQP(s)
	}
}

func (p *RFC5322Parser) ObsQP() (localctx IObsQPContext) {
	this := p
	_ = this

	localctx = NewObsQPContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, RFC5322ParserRULE_obsQP)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(748)
		p.Match(RFC5322ParserBackslash)
	}
	p.SetState(753)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case RFC5322ParserU_00:
		{
			p.SetState(749)
			p.Match(RFC5322ParserU_00)
		}

	case RFC5322ParserU_01_08, RFC5322ParserU_0B, RFC5322ParserU_0C, RFC5322ParserU_0E_1F, RFC5322ParserDelete:
		{
			p.SetState(750)
			p.ObsNoWSCTL()
		}

	case RFC5322ParserLF:
		{
			p.SetState(751)
			p.Match(RFC5322ParserLF)
		}

	case RFC5322ParserCR:
		{
			p.SetState(752)
			p.Match(RFC5322ParserCR)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IObsFWSContext is an interface to support dynamic dispatch.
type IObsFWSContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsObsFWSContext differentiates from other interfaces.
	IsObsFWSContext()
}

type ObsFWSContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObsFWSContext() *ObsFWSContext {
	var p = new(ObsFWSContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFC5322ParserRULE_obsFWS
	return p
}

func (*ObsFWSContext) IsObsFWSContext() {}

func NewObsFWSContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObsFWSContext {
	var p = new(ObsFWSContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC5322ParserRULE_obsFWS

	return p
}

func (s *ObsFWSContext) GetParser() antlr.Parser { return s.parser }

func (s *ObsFWSContext) Crlf() ICrlfContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICrlfContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICrlfContext)
}

func (s *ObsFWSContext) AllWsp() []IWspContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IWspContext); ok {
			len++
		}
	}

	tst := make([]IWspContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IWspContext); ok {
			tst[i] = t.(IWspContext)
			i++
		}
	}

	return tst
}

func (s *ObsFWSContext) Wsp(i int) IWspContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWspContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWspContext)
}

func (s *ObsFWSContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObsFWSContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObsFWSContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.EnterObsFWS(s)
	}
}

func (s *ObsFWSContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.ExitObsFWS(s)
	}
}

func (p *RFC5322Parser) ObsFWS() (localctx IObsFWSContext) {
	this := p
	_ = this

	localctx = NewObsFWSContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, RFC5322ParserRULE_obsFWS)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(756)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == RFC5322ParserTAB || _la == RFC5322ParserSP {
		{
			p.SetState(755)
			p.Wsp()
		}

		p.SetState(758)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	{
		p.SetState(760)
		p.Crlf()
	}
	p.SetState(762)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(761)
				p.Wsp()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(764)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 107, p.GetParserRuleContext())
	}

	return localctx
}

// IObsZoneContext is an interface to support dynamic dispatch.
type IObsZoneContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsObsZoneContext differentiates from other interfaces.
	IsObsZoneContext()
}

type ObsZoneContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObsZoneContext() *ObsZoneContext {
	var p = new(ObsZoneContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFC5322ParserRULE_obsZone
	return p
}

func (*ObsZoneContext) IsObsZoneContext() {}

func NewObsZoneContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObsZoneContext {
	var p = new(ObsZoneContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC5322ParserRULE_obsZone

	return p
}

func (s *ObsZoneContext) GetParser() antlr.Parser { return s.parser }

func (s *ObsZoneContext) U() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserU, 0)
}

func (s *ObsZoneContext) T() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserT, 0)
}

func (s *ObsZoneContext) C() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserC, 0)
}

func (s *ObsZoneContext) G() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserG, 0)
}

func (s *ObsZoneContext) M() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserM, 0)
}

func (s *ObsZoneContext) E() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserE, 0)
}

func (s *ObsZoneContext) S() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserS, 0)
}

func (s *ObsZoneContext) D() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserD, 0)
}

func (s *ObsZoneContext) P() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserP, 0)
}

func (s *ObsZoneContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObsZoneContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObsZoneContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.EnterObsZone(s)
	}
}

func (s *ObsZoneContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.ExitObsZone(s)
	}
}

func (p *RFC5322Parser) ObsZone() (localctx IObsZoneContext) {
	this := p
	_ = this

	localctx = NewObsZoneContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, RFC5322ParserRULE_obsZone)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(798)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 108, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(766)
			p.Match(RFC5322ParserU)
		}
		{
			p.SetState(767)
			p.Match(RFC5322ParserT)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(768)
			p.Match(RFC5322ParserU)
		}
		{
			p.SetState(769)
			p.Match(RFC5322ParserT)
		}
		{
			p.SetState(770)
			p.Match(RFC5322ParserC)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(771)
			p.Match(RFC5322ParserG)
		}
		{
			p.SetState(772)
			p.Match(RFC5322ParserM)
		}
		{
			p.SetState(773)
			p.Match(RFC5322ParserT)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(774)
			p.Match(RFC5322ParserE)
		}
		{
			p.SetState(775)
			p.Match(RFC5322ParserS)
		}
		{
			p.SetState(776)
			p.Match(RFC5322ParserT)
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(777)
			p.Match(RFC5322ParserE)
		}
		{
			p.SetState(778)
			p.Match(RFC5322ParserD)
		}
		{
			p.SetState(779)
			p.Match(RFC5322ParserT)
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(780)
			p.Match(RFC5322ParserC)
		}
		{
			p.SetState(781)
			p.Match(RFC5322ParserS)
		}
		{
			p.SetState(782)
			p.Match(RFC5322ParserT)
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(783)
			p.Match(RFC5322ParserC)
		}
		{
			p.SetState(784)
			p.Match(RFC5322ParserD)
		}
		{
			p.SetState(785)
			p.Match(RFC5322ParserT)
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(786)
			p.Match(RFC5322ParserM)
		}
		{
			p.SetState(787)
			p.Match(RFC5322ParserS)
		}
		{
			p.SetState(788)
			p.Match(RFC5322ParserT)
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(789)
			p.Match(RFC5322ParserM)
		}
		{
			p.SetState(790)
			p.Match(RFC5322ParserD)
		}
		{
			p.SetState(791)
			p.Match(RFC5322ParserT)
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(792)
			p.Match(RFC5322ParserP)
		}
		{
			p.SetState(793)
			p.Match(RFC5322ParserS)
		}
		{
			p.SetState(794)
			p.Match(RFC5322ParserT)
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(795)
			p.Match(RFC5322ParserP)
		}
		{
			p.SetState(796)
			p.Match(RFC5322ParserD)
		}
		{
			p.SetState(797)
			p.Match(RFC5322ParserT)
		}

	}

	return localctx
}

// IObsAngleAddrContext is an interface to support dynamic dispatch.
type IObsAngleAddrContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsObsAngleAddrContext differentiates from other interfaces.
	IsObsAngleAddrContext()
}

type ObsAngleAddrContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObsAngleAddrContext() *ObsAngleAddrContext {
	var p = new(ObsAngleAddrContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFC5322ParserRULE_obsAngleAddr
	return p
}

func (*ObsAngleAddrContext) IsObsAngleAddrContext() {}

func NewObsAngleAddrContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObsAngleAddrContext {
	var p = new(ObsAngleAddrContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC5322ParserRULE_obsAngleAddr

	return p
}

func (s *ObsAngleAddrContext) GetParser() antlr.Parser { return s.parser }

func (s *ObsAngleAddrContext) Less() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserLess, 0)
}

func (s *ObsAngleAddrContext) ObsRoute() IObsRouteContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObsRouteContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObsRouteContext)
}

func (s *ObsAngleAddrContext) AddrSpec() IAddrSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAddrSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAddrSpecContext)
}

func (s *ObsAngleAddrContext) Greater() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserGreater, 0)
}

func (s *ObsAngleAddrContext) AllCfws() []ICfwsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICfwsContext); ok {
			len++
		}
	}

	tst := make([]ICfwsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICfwsContext); ok {
			tst[i] = t.(ICfwsContext)
			i++
		}
	}

	return tst
}

func (s *ObsAngleAddrContext) Cfws(i int) ICfwsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICfwsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICfwsContext)
}

func (s *ObsAngleAddrContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObsAngleAddrContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObsAngleAddrContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.EnterObsAngleAddr(s)
	}
}

func (s *ObsAngleAddrContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.ExitObsAngleAddr(s)
	}
}

func (p *RFC5322Parser) ObsAngleAddr() (localctx IObsAngleAddrContext) {
	this := p
	_ = this

	localctx = NewObsAngleAddrContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, RFC5322ParserRULE_obsAngleAddr)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(801)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RFC5322ParserTAB)|(1<<RFC5322ParserCR)|(1<<RFC5322ParserSP)|(1<<RFC5322ParserLParens))) != 0 {
		{
			p.SetState(800)
			p.Cfws()
		}

	}
	{
		p.SetState(803)
		p.Match(RFC5322ParserLess)
	}
	{
		p.SetState(804)
		p.ObsRoute()
	}
	{
		p.SetState(805)
		p.AddrSpec()
	}
	{
		p.SetState(806)
		p.Match(RFC5322ParserGreater)
	}
	p.SetState(808)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 110, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(807)
			p.Cfws()
		}

	}

	return localctx
}

// IObsRouteContext is an interface to support dynamic dispatch.
type IObsRouteContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsObsRouteContext differentiates from other interfaces.
	IsObsRouteContext()
}

type ObsRouteContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObsRouteContext() *ObsRouteContext {
	var p = new(ObsRouteContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFC5322ParserRULE_obsRoute
	return p
}

func (*ObsRouteContext) IsObsRouteContext() {}

func NewObsRouteContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObsRouteContext {
	var p = new(ObsRouteContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC5322ParserRULE_obsRoute

	return p
}

func (s *ObsRouteContext) GetParser() antlr.Parser { return s.parser }

func (s *ObsRouteContext) ObsDomainList() IObsDomainListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObsDomainListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObsDomainListContext)
}

func (s *ObsRouteContext) Colon() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserColon, 0)
}

func (s *ObsRouteContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObsRouteContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObsRouteContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.EnterObsRoute(s)
	}
}

func (s *ObsRouteContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.ExitObsRoute(s)
	}
}

func (p *RFC5322Parser) ObsRoute() (localctx IObsRouteContext) {
	this := p
	_ = this

	localctx = NewObsRouteContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, RFC5322ParserRULE_obsRoute)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(810)
		p.ObsDomainList()
	}
	{
		p.SetState(811)
		p.Match(RFC5322ParserColon)
	}

	return localctx
}

// IObsDomainListContext is an interface to support dynamic dispatch.
type IObsDomainListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsObsDomainListContext differentiates from other interfaces.
	IsObsDomainListContext()
}

type ObsDomainListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObsDomainListContext() *ObsDomainListContext {
	var p = new(ObsDomainListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFC5322ParserRULE_obsDomainList
	return p
}

func (*ObsDomainListContext) IsObsDomainListContext() {}

func NewObsDomainListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObsDomainListContext {
	var p = new(ObsDomainListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC5322ParserRULE_obsDomainList

	return p
}

func (s *ObsDomainListContext) GetParser() antlr.Parser { return s.parser }

func (s *ObsDomainListContext) AllAt() []antlr.TerminalNode {
	return s.GetTokens(RFC5322ParserAt)
}

func (s *ObsDomainListContext) At(i int) antlr.TerminalNode {
	return s.GetToken(RFC5322ParserAt, i)
}

func (s *ObsDomainListContext) AllDomain() []IDomainContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDomainContext); ok {
			len++
		}
	}

	tst := make([]IDomainContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDomainContext); ok {
			tst[i] = t.(IDomainContext)
			i++
		}
	}

	return tst
}

func (s *ObsDomainListContext) Domain(i int) IDomainContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDomainContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDomainContext)
}

func (s *ObsDomainListContext) AllCfws() []ICfwsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICfwsContext); ok {
			len++
		}
	}

	tst := make([]ICfwsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICfwsContext); ok {
			tst[i] = t.(ICfwsContext)
			i++
		}
	}

	return tst
}

func (s *ObsDomainListContext) Cfws(i int) ICfwsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICfwsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICfwsContext)
}

func (s *ObsDomainListContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(RFC5322ParserComma)
}

func (s *ObsDomainListContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(RFC5322ParserComma, i)
}

func (s *ObsDomainListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObsDomainListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObsDomainListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.EnterObsDomainList(s)
	}
}

func (s *ObsDomainListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.ExitObsDomainList(s)
	}
}

func (p *RFC5322Parser) ObsDomainList() (localctx IObsDomainListContext) {
	this := p
	_ = this

	localctx = NewObsDomainListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, RFC5322ParserRULE_obsDomainList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(817)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RFC5322ParserTAB)|(1<<RFC5322ParserCR)|(1<<RFC5322ParserSP)|(1<<RFC5322ParserLParens)|(1<<RFC5322ParserComma))) != 0 {
		p.SetState(815)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case RFC5322ParserTAB, RFC5322ParserCR, RFC5322ParserSP, RFC5322ParserLParens:
			{
				p.SetState(813)
				p.Cfws()
			}

		case RFC5322ParserComma:
			{
				p.SetState(814)
				p.Match(RFC5322ParserComma)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(819)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(820)
		p.Match(RFC5322ParserAt)
	}
	{
		p.SetState(821)
		p.Domain()
	}
	p.SetState(832)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == RFC5322ParserComma {
		{
			p.SetState(822)
			p.Match(RFC5322ParserComma)
		}
		p.SetState(824)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RFC5322ParserTAB)|(1<<RFC5322ParserCR)|(1<<RFC5322ParserSP)|(1<<RFC5322ParserLParens))) != 0 {
			{
				p.SetState(823)
				p.Cfws()
			}

		}
		p.SetState(828)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == RFC5322ParserAt {
			{
				p.SetState(826)
				p.Match(RFC5322ParserAt)
			}
			{
				p.SetState(827)
				p.Domain()
			}

		}

		p.SetState(834)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IObsMboxListContext is an interface to support dynamic dispatch.
type IObsMboxListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsObsMboxListContext differentiates from other interfaces.
	IsObsMboxListContext()
}

type ObsMboxListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObsMboxListContext() *ObsMboxListContext {
	var p = new(ObsMboxListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFC5322ParserRULE_obsMboxList
	return p
}

func (*ObsMboxListContext) IsObsMboxListContext() {}

func NewObsMboxListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObsMboxListContext {
	var p = new(ObsMboxListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC5322ParserRULE_obsMboxList

	return p
}

func (s *ObsMboxListContext) GetParser() antlr.Parser { return s.parser }

func (s *ObsMboxListContext) AllMailbox() []IMailboxContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMailboxContext); ok {
			len++
		}
	}

	tst := make([]IMailboxContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMailboxContext); ok {
			tst[i] = t.(IMailboxContext)
			i++
		}
	}

	return tst
}

func (s *ObsMboxListContext) Mailbox(i int) IMailboxContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMailboxContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMailboxContext)
}

func (s *ObsMboxListContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(RFC5322ParserComma)
}

func (s *ObsMboxListContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(RFC5322ParserComma, i)
}

func (s *ObsMboxListContext) AllCfws() []ICfwsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICfwsContext); ok {
			len++
		}
	}

	tst := make([]ICfwsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICfwsContext); ok {
			tst[i] = t.(ICfwsContext)
			i++
		}
	}

	return tst
}

func (s *ObsMboxListContext) Cfws(i int) ICfwsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICfwsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICfwsContext)
}

func (s *ObsMboxListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObsMboxListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObsMboxListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.EnterObsMboxList(s)
	}
}

func (s *ObsMboxListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.ExitObsMboxList(s)
	}
}

func (p *RFC5322Parser) ObsMboxList() (localctx IObsMboxListContext) {
	this := p
	_ = this

	localctx = NewObsMboxListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, RFC5322ParserRULE_obsMboxList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(841)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 117, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(836)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RFC5322ParserTAB)|(1<<RFC5322ParserCR)|(1<<RFC5322ParserSP)|(1<<RFC5322ParserLParens))) != 0 {
				{
					p.SetState(835)
					p.Cfws()
				}

			}
			{
				p.SetState(838)
				p.Match(RFC5322ParserComma)
			}

		}
		p.SetState(843)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 117, p.GetParserRuleContext())
	}
	{
		p.SetState(844)
		p.Mailbox()
	}
	p.SetState(852)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 119, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(845)
				p.Match(RFC5322ParserComma)
			}
			p.SetState(848)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 118, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(846)
					p.Mailbox()
				}

			} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 118, p.GetParserRuleContext()) == 2 {
				{
					p.SetState(847)
					p.Cfws()
				}

			}

		}
		p.SetState(854)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 119, p.GetParserRuleContext())
	}

	return localctx
}

// IObsAddrListContext is an interface to support dynamic dispatch.
type IObsAddrListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsObsAddrListContext differentiates from other interfaces.
	IsObsAddrListContext()
}

type ObsAddrListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObsAddrListContext() *ObsAddrListContext {
	var p = new(ObsAddrListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFC5322ParserRULE_obsAddrList
	return p
}

func (*ObsAddrListContext) IsObsAddrListContext() {}

func NewObsAddrListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObsAddrListContext {
	var p = new(ObsAddrListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC5322ParserRULE_obsAddrList

	return p
}

func (s *ObsAddrListContext) GetParser() antlr.Parser { return s.parser }

func (s *ObsAddrListContext) AllAddress() []IAddressContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAddressContext); ok {
			len++
		}
	}

	tst := make([]IAddressContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAddressContext); ok {
			tst[i] = t.(IAddressContext)
			i++
		}
	}

	return tst
}

func (s *ObsAddrListContext) Address(i int) IAddressContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAddressContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAddressContext)
}

func (s *ObsAddrListContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(RFC5322ParserComma)
}

func (s *ObsAddrListContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(RFC5322ParserComma, i)
}

func (s *ObsAddrListContext) AllCfws() []ICfwsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICfwsContext); ok {
			len++
		}
	}

	tst := make([]ICfwsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICfwsContext); ok {
			tst[i] = t.(ICfwsContext)
			i++
		}
	}

	return tst
}

func (s *ObsAddrListContext) Cfws(i int) ICfwsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICfwsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICfwsContext)
}

func (s *ObsAddrListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObsAddrListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObsAddrListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.EnterObsAddrList(s)
	}
}

func (s *ObsAddrListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.ExitObsAddrList(s)
	}
}

func (p *RFC5322Parser) ObsAddrList() (localctx IObsAddrListContext) {
	this := p
	_ = this

	localctx = NewObsAddrListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, RFC5322ParserRULE_obsAddrList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(861)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 121, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(856)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RFC5322ParserTAB)|(1<<RFC5322ParserCR)|(1<<RFC5322ParserSP)|(1<<RFC5322ParserLParens))) != 0 {
				{
					p.SetState(855)
					p.Cfws()
				}

			}
			{
				p.SetState(858)
				p.Match(RFC5322ParserComma)
			}

		}
		p.SetState(863)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 121, p.GetParserRuleContext())
	}
	{
		p.SetState(864)
		p.Address()
	}
	p.SetState(872)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == RFC5322ParserComma {
		{
			p.SetState(865)
			p.Match(RFC5322ParserComma)
		}
		p.SetState(868)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 122, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(866)
				p.Address()
			}

		} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 122, p.GetParserRuleContext()) == 2 {
			{
				p.SetState(867)
				p.Cfws()
			}

		}

		p.SetState(874)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IObsGroupListContext is an interface to support dynamic dispatch.
type IObsGroupListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsObsGroupListContext differentiates from other interfaces.
	IsObsGroupListContext()
}

type ObsGroupListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObsGroupListContext() *ObsGroupListContext {
	var p = new(ObsGroupListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFC5322ParserRULE_obsGroupList
	return p
}

func (*ObsGroupListContext) IsObsGroupListContext() {}

func NewObsGroupListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObsGroupListContext {
	var p = new(ObsGroupListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC5322ParserRULE_obsGroupList

	return p
}

func (s *ObsGroupListContext) GetParser() antlr.Parser { return s.parser }

func (s *ObsGroupListContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(RFC5322ParserComma)
}

func (s *ObsGroupListContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(RFC5322ParserComma, i)
}

func (s *ObsGroupListContext) AllCfws() []ICfwsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICfwsContext); ok {
			len++
		}
	}

	tst := make([]ICfwsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICfwsContext); ok {
			tst[i] = t.(ICfwsContext)
			i++
		}
	}

	return tst
}

func (s *ObsGroupListContext) Cfws(i int) ICfwsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICfwsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICfwsContext)
}

func (s *ObsGroupListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObsGroupListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObsGroupListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.EnterObsGroupList(s)
	}
}

func (s *ObsGroupListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.ExitObsGroupList(s)
	}
}

func (p *RFC5322Parser) ObsGroupList() (localctx IObsGroupListContext) {
	this := p
	_ = this

	localctx = NewObsGroupListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, RFC5322ParserRULE_obsGroupList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(879)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			p.SetState(876)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RFC5322ParserTAB)|(1<<RFC5322ParserCR)|(1<<RFC5322ParserSP)|(1<<RFC5322ParserLParens))) != 0 {
				{
					p.SetState(875)
					p.Cfws()
				}

			}
			{
				p.SetState(878)
				p.Match(RFC5322ParserComma)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(881)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 125, p.GetParserRuleContext())
	}
	p.SetState(884)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 126, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(883)
			p.Cfws()
		}

	}

	return localctx
}

// IObsLocalPartContext is an interface to support dynamic dispatch.
type IObsLocalPartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsObsLocalPartContext differentiates from other interfaces.
	IsObsLocalPartContext()
}

type ObsLocalPartContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObsLocalPartContext() *ObsLocalPartContext {
	var p = new(ObsLocalPartContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFC5322ParserRULE_obsLocalPart
	return p
}

func (*ObsLocalPartContext) IsObsLocalPartContext() {}

func NewObsLocalPartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObsLocalPartContext {
	var p = new(ObsLocalPartContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC5322ParserRULE_obsLocalPart

	return p
}

func (s *ObsLocalPartContext) GetParser() antlr.Parser { return s.parser }

func (s *ObsLocalPartContext) AllWord() []IWordContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IWordContext); ok {
			len++
		}
	}

	tst := make([]IWordContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IWordContext); ok {
			tst[i] = t.(IWordContext)
			i++
		}
	}

	return tst
}

func (s *ObsLocalPartContext) Word(i int) IWordContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWordContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWordContext)
}

func (s *ObsLocalPartContext) AllPeriod() []antlr.TerminalNode {
	return s.GetTokens(RFC5322ParserPeriod)
}

func (s *ObsLocalPartContext) Period(i int) antlr.TerminalNode {
	return s.GetToken(RFC5322ParserPeriod, i)
}

func (s *ObsLocalPartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObsLocalPartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObsLocalPartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.EnterObsLocalPart(s)
	}
}

func (s *ObsLocalPartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.ExitObsLocalPart(s)
	}
}

func (p *RFC5322Parser) ObsLocalPart() (localctx IObsLocalPartContext) {
	this := p
	_ = this

	localctx = NewObsLocalPartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, RFC5322ParserRULE_obsLocalPart)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(886)
		p.Word()
	}
	p.SetState(891)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == RFC5322ParserPeriod {
		{
			p.SetState(887)
			p.Match(RFC5322ParserPeriod)
		}
		{
			p.SetState(888)
			p.Word()
		}

		p.SetState(893)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IObsDomainContext is an interface to support dynamic dispatch.
type IObsDomainContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsObsDomainContext differentiates from other interfaces.
	IsObsDomainContext()
}

type ObsDomainContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObsDomainContext() *ObsDomainContext {
	var p = new(ObsDomainContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFC5322ParserRULE_obsDomain
	return p
}

func (*ObsDomainContext) IsObsDomainContext() {}

func NewObsDomainContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObsDomainContext {
	var p = new(ObsDomainContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC5322ParserRULE_obsDomain

	return p
}

func (s *ObsDomainContext) GetParser() antlr.Parser { return s.parser }

func (s *ObsDomainContext) AllAtom() []IAtomContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAtomContext); ok {
			len++
		}
	}

	tst := make([]IAtomContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAtomContext); ok {
			tst[i] = t.(IAtomContext)
			i++
		}
	}

	return tst
}

func (s *ObsDomainContext) Atom(i int) IAtomContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAtomContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAtomContext)
}

func (s *ObsDomainContext) AllPeriod() []antlr.TerminalNode {
	return s.GetTokens(RFC5322ParserPeriod)
}

func (s *ObsDomainContext) Period(i int) antlr.TerminalNode {
	return s.GetToken(RFC5322ParserPeriod, i)
}

func (s *ObsDomainContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObsDomainContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObsDomainContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.EnterObsDomain(s)
	}
}

func (s *ObsDomainContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.ExitObsDomain(s)
	}
}

func (p *RFC5322Parser) ObsDomain() (localctx IObsDomainContext) {
	this := p
	_ = this

	localctx = NewObsDomainContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, RFC5322ParserRULE_obsDomain)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(894)
		p.Atom()
	}
	p.SetState(899)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == RFC5322ParserPeriod {
		{
			p.SetState(895)
			p.Match(RFC5322ParserPeriod)
		}
		{
			p.SetState(896)
			p.Atom()
		}

		p.SetState(901)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IEncodedWordContext is an interface to support dynamic dispatch.
type IEncodedWordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEncodedWordContext differentiates from other interfaces.
	IsEncodedWordContext()
}

type EncodedWordContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEncodedWordContext() *EncodedWordContext {
	var p = new(EncodedWordContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFC5322ParserRULE_encodedWord
	return p
}

func (*EncodedWordContext) IsEncodedWordContext() {}

func NewEncodedWordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EncodedWordContext {
	var p = new(EncodedWordContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC5322ParserRULE_encodedWord

	return p
}

func (s *EncodedWordContext) GetParser() antlr.Parser { return s.parser }

func (s *EncodedWordContext) AllEqual() []antlr.TerminalNode {
	return s.GetTokens(RFC5322ParserEqual)
}

func (s *EncodedWordContext) Equal(i int) antlr.TerminalNode {
	return s.GetToken(RFC5322ParserEqual, i)
}

func (s *EncodedWordContext) AllQuestion() []antlr.TerminalNode {
	return s.GetTokens(RFC5322ParserQuestion)
}

func (s *EncodedWordContext) Question(i int) antlr.TerminalNode {
	return s.GetToken(RFC5322ParserQuestion, i)
}

func (s *EncodedWordContext) Charset() ICharsetContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharsetContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharsetContext)
}

func (s *EncodedWordContext) Encoding() IEncodingContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEncodingContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEncodingContext)
}

func (s *EncodedWordContext) EncodedText() IEncodedTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEncodedTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEncodedTextContext)
}

func (s *EncodedWordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EncodedWordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EncodedWordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.EnterEncodedWord(s)
	}
}

func (s *EncodedWordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.ExitEncodedWord(s)
	}
}

func (p *RFC5322Parser) EncodedWord() (localctx IEncodedWordContext) {
	this := p
	_ = this

	localctx = NewEncodedWordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, RFC5322ParserRULE_encodedWord)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(902)
		p.Match(RFC5322ParserEqual)
	}
	{
		p.SetState(903)
		p.Match(RFC5322ParserQuestion)
	}
	{
		p.SetState(904)
		p.Charset()
	}
	{
		p.SetState(905)
		p.Match(RFC5322ParserQuestion)
	}
	{
		p.SetState(906)
		p.Encoding()
	}
	{
		p.SetState(907)
		p.Match(RFC5322ParserQuestion)
	}
	{
		p.SetState(908)
		p.EncodedText()
	}
	{
		p.SetState(909)
		p.Match(RFC5322ParserQuestion)
	}
	{
		p.SetState(910)
		p.Match(RFC5322ParserEqual)
	}

	return localctx
}

// ICharsetContext is an interface to support dynamic dispatch.
type ICharsetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCharsetContext differentiates from other interfaces.
	IsCharsetContext()
}

type CharsetContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCharsetContext() *CharsetContext {
	var p = new(CharsetContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFC5322ParserRULE_charset
	return p
}

func (*CharsetContext) IsCharsetContext() {}

func NewCharsetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CharsetContext {
	var p = new(CharsetContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC5322ParserRULE_charset

	return p
}

func (s *CharsetContext) GetParser() antlr.Parser { return s.parser }

func (s *CharsetContext) Token() ITokenContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITokenContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITokenContext)
}

func (s *CharsetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CharsetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CharsetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.EnterCharset(s)
	}
}

func (s *CharsetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.ExitCharset(s)
	}
}

func (p *RFC5322Parser) Charset() (localctx ICharsetContext) {
	this := p
	_ = this

	localctx = NewCharsetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, RFC5322ParserRULE_charset)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(912)
		p.Token()
	}

	return localctx
}

// IEncodingContext is an interface to support dynamic dispatch.
type IEncodingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEncodingContext differentiates from other interfaces.
	IsEncodingContext()
}

type EncodingContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEncodingContext() *EncodingContext {
	var p = new(EncodingContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFC5322ParserRULE_encoding
	return p
}

func (*EncodingContext) IsEncodingContext() {}

func NewEncodingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EncodingContext {
	var p = new(EncodingContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC5322ParserRULE_encoding

	return p
}

func (s *EncodingContext) GetParser() antlr.Parser { return s.parser }

func (s *EncodingContext) Token() ITokenContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITokenContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITokenContext)
}

func (s *EncodingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EncodingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EncodingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.EnterEncoding(s)
	}
}

func (s *EncodingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.ExitEncoding(s)
	}
}

func (p *RFC5322Parser) Encoding() (localctx IEncodingContext) {
	this := p
	_ = this

	localctx = NewEncodingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, RFC5322ParserRULE_encoding)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(914)
		p.Token()
	}

	return localctx
}

// ITokenContext is an interface to support dynamic dispatch.
type ITokenContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTokenContext differentiates from other interfaces.
	IsTokenContext()
}

type TokenContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTokenContext() *TokenContext {
	var p = new(TokenContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFC5322ParserRULE_token
	return p
}

func (*TokenContext) IsTokenContext() {}

func NewTokenContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TokenContext {
	var p = new(TokenContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC5322ParserRULE_token

	return p
}

func (s *TokenContext) GetParser() antlr.Parser { return s.parser }

func (s *TokenContext) AllTokenChar() []ITokenCharContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITokenCharContext); ok {
			len++
		}
	}

	tst := make([]ITokenCharContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITokenCharContext); ok {
			tst[i] = t.(ITokenCharContext)
			i++
		}
	}

	return tst
}

func (s *TokenContext) TokenChar(i int) ITokenCharContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITokenCharContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITokenCharContext)
}

func (s *TokenContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TokenContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TokenContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.EnterToken(s)
	}
}

func (s *TokenContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.ExitToken(s)
	}
}

func (p *RFC5322Parser) Token() (localctx ITokenContext) {
	this := p
	_ = this

	localctx = NewTokenContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, RFC5322ParserRULE_token)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(917)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la-10)&-(0x1f+1)) == 0 && ((1<<uint((_la-10)))&((1<<(RFC5322ParserExclamation-10))|(1<<(RFC5322ParserHash-10))|(1<<(RFC5322ParserDollar-10))|(1<<(RFC5322ParserPercent-10))|(1<<(RFC5322ParserAmpersand-10))|(1<<(RFC5322ParserSQuote-10))|(1<<(RFC5322ParserAsterisk-10))|(1<<(RFC5322ParserPlus-10))|(1<<(RFC5322ParserMinus-10))|(1<<(RFC5322ParserDigit-10))|(1<<(RFC5322ParserBackslash-10))|(1<<(RFC5322ParserCaret-10))|(1<<(RFC5322ParserUnderscore-10))|(1<<(RFC5322ParserBacktick-10))|(1<<(RFC5322ParserLCurly-10))|(1<<(RFC5322ParserPipe-10))|(1<<(RFC5322ParserRCurly-10)))) != 0) || (((_la-42)&-(0x1f+1)) == 0 && ((1<<uint((_la-42)))&((1<<(RFC5322ParserTilde-42))|(1<<(RFC5322ParserA-42))|(1<<(RFC5322ParserB-42))|(1<<(RFC5322ParserC-42))|(1<<(RFC5322ParserD-42))|(1<<(RFC5322ParserE-42))|(1<<(RFC5322ParserF-42))|(1<<(RFC5322ParserG-42))|(1<<(RFC5322ParserH-42))|(1<<(RFC5322ParserI-42))|(1<<(RFC5322ParserJ-42))|(1<<(RFC5322ParserK-42))|(1<<(RFC5322ParserL-42))|(1<<(RFC5322ParserM-42))|(1<<(RFC5322ParserN-42))|(1<<(RFC5322ParserO-42))|(1<<(RFC5322ParserP-42))|(1<<(RFC5322ParserQ-42))|(1<<(RFC5322ParserR-42))|(1<<(RFC5322ParserS-42))|(1<<(RFC5322ParserT-42))|(1<<(RFC5322ParserU-42))|(1<<(RFC5322ParserV-42))|(1<<(RFC5322ParserW-42))|(1<<(RFC5322ParserX-42))|(1<<(RFC5322ParserY-42))|(1<<(RFC5322ParserZ-42)))) != 0) {
		{
			p.SetState(916)
			p.TokenChar()
		}

		p.SetState(919)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ITokenCharContext is an interface to support dynamic dispatch.
type ITokenCharContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTokenCharContext differentiates from other interfaces.
	IsTokenCharContext()
}

type TokenCharContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTokenCharContext() *TokenCharContext {
	var p = new(TokenCharContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFC5322ParserRULE_tokenChar
	return p
}

func (*TokenCharContext) IsTokenCharContext() {}

func NewTokenCharContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TokenCharContext {
	var p = new(TokenCharContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC5322ParserRULE_tokenChar

	return p
}

func (s *TokenCharContext) GetParser() antlr.Parser { return s.parser }

func (s *TokenCharContext) Alpha() IAlphaContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlphaContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlphaContext)
}

func (s *TokenCharContext) Exclamation() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserExclamation, 0)
}

func (s *TokenCharContext) Hash() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserHash, 0)
}

func (s *TokenCharContext) Dollar() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserDollar, 0)
}

func (s *TokenCharContext) Percent() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserPercent, 0)
}

func (s *TokenCharContext) Ampersand() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserAmpersand, 0)
}

func (s *TokenCharContext) SQuote() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserSQuote, 0)
}

func (s *TokenCharContext) Asterisk() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserAsterisk, 0)
}

func (s *TokenCharContext) Plus() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserPlus, 0)
}

func (s *TokenCharContext) Minus() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserMinus, 0)
}

func (s *TokenCharContext) Digit() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserDigit, 0)
}

func (s *TokenCharContext) Backslash() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserBackslash, 0)
}

func (s *TokenCharContext) Caret() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserCaret, 0)
}

func (s *TokenCharContext) Underscore() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserUnderscore, 0)
}

func (s *TokenCharContext) Backtick() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserBacktick, 0)
}

func (s *TokenCharContext) LCurly() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserLCurly, 0)
}

func (s *TokenCharContext) Pipe() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserPipe, 0)
}

func (s *TokenCharContext) RCurly() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserRCurly, 0)
}

func (s *TokenCharContext) Tilde() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserTilde, 0)
}

func (s *TokenCharContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TokenCharContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TokenCharContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.EnterTokenChar(s)
	}
}

func (s *TokenCharContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.ExitTokenChar(s)
	}
}

func (p *RFC5322Parser) TokenChar() (localctx ITokenCharContext) {
	this := p
	_ = this

	localctx = NewTokenCharContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, RFC5322ParserRULE_tokenChar)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(940)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case RFC5322ParserA, RFC5322ParserB, RFC5322ParserC, RFC5322ParserD, RFC5322ParserE, RFC5322ParserF, RFC5322ParserG, RFC5322ParserH, RFC5322ParserI, RFC5322ParserJ, RFC5322ParserK, RFC5322ParserL, RFC5322ParserM, RFC5322ParserN, RFC5322ParserO, RFC5322ParserP, RFC5322ParserQ, RFC5322ParserR, RFC5322ParserS, RFC5322ParserT, RFC5322ParserU, RFC5322ParserV, RFC5322ParserW, RFC5322ParserX, RFC5322ParserY, RFC5322ParserZ:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(921)
			p.Alpha()
		}

	case RFC5322ParserExclamation:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(922)
			p.Match(RFC5322ParserExclamation)
		}

	case RFC5322ParserHash:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(923)
			p.Match(RFC5322ParserHash)
		}

	case RFC5322ParserDollar:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(924)
			p.Match(RFC5322ParserDollar)
		}

	case RFC5322ParserPercent:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(925)
			p.Match(RFC5322ParserPercent)
		}

	case RFC5322ParserAmpersand:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(926)
			p.Match(RFC5322ParserAmpersand)
		}

	case RFC5322ParserSQuote:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(927)
			p.Match(RFC5322ParserSQuote)
		}

	case RFC5322ParserAsterisk:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(928)
			p.Match(RFC5322ParserAsterisk)
		}

	case RFC5322ParserPlus:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(929)
			p.Match(RFC5322ParserPlus)
		}

	case RFC5322ParserMinus:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(930)
			p.Match(RFC5322ParserMinus)
		}

	case RFC5322ParserDigit:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(931)
			p.Match(RFC5322ParserDigit)
		}

	case RFC5322ParserBackslash:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(932)
			p.Match(RFC5322ParserBackslash)
		}

	case RFC5322ParserCaret:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(933)
			p.Match(RFC5322ParserCaret)
		}

	case RFC5322ParserUnderscore:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(934)
			p.Match(RFC5322ParserUnderscore)
		}

	case RFC5322ParserBacktick:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(935)
			p.Match(RFC5322ParserBacktick)
		}

	case RFC5322ParserLCurly:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(936)
			p.Match(RFC5322ParserLCurly)
		}

	case RFC5322ParserPipe:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(937)
			p.Match(RFC5322ParserPipe)
		}

	case RFC5322ParserRCurly:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(938)
			p.Match(RFC5322ParserRCurly)
		}

	case RFC5322ParserTilde:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(939)
			p.Match(RFC5322ParserTilde)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IEncodedTextContext is an interface to support dynamic dispatch.
type IEncodedTextContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEncodedTextContext differentiates from other interfaces.
	IsEncodedTextContext()
}

type EncodedTextContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEncodedTextContext() *EncodedTextContext {
	var p = new(EncodedTextContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFC5322ParserRULE_encodedText
	return p
}

func (*EncodedTextContext) IsEncodedTextContext() {}

func NewEncodedTextContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EncodedTextContext {
	var p = new(EncodedTextContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC5322ParserRULE_encodedText

	return p
}

func (s *EncodedTextContext) GetParser() antlr.Parser { return s.parser }

func (s *EncodedTextContext) AllEncodedChar() []IEncodedCharContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEncodedCharContext); ok {
			len++
		}
	}

	tst := make([]IEncodedCharContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEncodedCharContext); ok {
			tst[i] = t.(IEncodedCharContext)
			i++
		}
	}

	return tst
}

func (s *EncodedTextContext) EncodedChar(i int) IEncodedCharContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEncodedCharContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEncodedCharContext)
}

func (s *EncodedTextContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EncodedTextContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EncodedTextContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.EnterEncodedText(s)
	}
}

func (s *EncodedTextContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.ExitEncodedText(s)
	}
}

func (p *RFC5322Parser) EncodedText() (localctx IEncodedTextContext) {
	this := p
	_ = this

	localctx = NewEncodedTextContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, RFC5322ParserRULE_encodedText)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(943)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la-10)&-(0x1f+1)) == 0 && ((1<<uint((_la-10)))&((1<<(RFC5322ParserExclamation-10))|(1<<(RFC5322ParserDQuote-10))|(1<<(RFC5322ParserHash-10))|(1<<(RFC5322ParserDollar-10))|(1<<(RFC5322ParserPercent-10))|(1<<(RFC5322ParserAmpersand-10))|(1<<(RFC5322ParserSQuote-10))|(1<<(RFC5322ParserLParens-10))|(1<<(RFC5322ParserRParens-10))|(1<<(RFC5322ParserAsterisk-10))|(1<<(RFC5322ParserPlus-10))|(1<<(RFC5322ParserComma-10))|(1<<(RFC5322ParserMinus-10))|(1<<(RFC5322ParserPeriod-10))|(1<<(RFC5322ParserSlash-10))|(1<<(RFC5322ParserDigit-10))|(1<<(RFC5322ParserColon-10))|(1<<(RFC5322ParserSemicolon-10))|(1<<(RFC5322ParserLess-10))|(1<<(RFC5322ParserEqual-10))|(1<<(RFC5322ParserGreater-10))|(1<<(RFC5322ParserAt-10))|(1<<(RFC5322ParserLBracket-10))|(1<<(RFC5322ParserBackslash-10))|(1<<(RFC5322ParserRBracket-10))|(1<<(RFC5322ParserCaret-10))|(1<<(RFC5322ParserUnderscore-10))|(1<<(RFC5322ParserBacktick-10))|(1<<(RFC5322ParserLCurly-10))|(1<<(RFC5322ParserPipe-10))|(1<<(RFC5322ParserRCurly-10)))) != 0) || (((_la-42)&-(0x1f+1)) == 0 && ((1<<uint((_la-42)))&((1<<(RFC5322ParserTilde-42))|(1<<(RFC5322ParserA-42))|(1<<(RFC5322ParserB-42))|(1<<(RFC5322ParserC-42))|(1<<(RFC5322ParserD-42))|(1<<(RFC5322ParserE-42))|(1<<(RFC5322ParserF-42))|(1<<(RFC5322ParserG-42))|(1<<(RFC5322ParserH-42))|(1<<(RFC5322ParserI-42))|(1<<(RFC5322ParserJ-42))|(1<<(RFC5322ParserK-42))|(1<<(RFC5322ParserL-42))|(1<<(RFC5322ParserM-42))|(1<<(RFC5322ParserN-42))|(1<<(RFC5322ParserO-42))|(1<<(RFC5322ParserP-42))|(1<<(RFC5322ParserQ-42))|(1<<(RFC5322ParserR-42))|(1<<(RFC5322ParserS-42))|(1<<(RFC5322ParserT-42))|(1<<(RFC5322ParserU-42))|(1<<(RFC5322ParserV-42))|(1<<(RFC5322ParserW-42))|(1<<(RFC5322ParserX-42))|(1<<(RFC5322ParserY-42))|(1<<(RFC5322ParserZ-42)))) != 0) {
		{
			p.SetState(942)
			p.EncodedChar()
		}

		p.SetState(945)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IEncodedCharContext is an interface to support dynamic dispatch.
type IEncodedCharContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEncodedCharContext differentiates from other interfaces.
	IsEncodedCharContext()
}

type EncodedCharContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEncodedCharContext() *EncodedCharContext {
	var p = new(EncodedCharContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFC5322ParserRULE_encodedChar
	return p
}

func (*EncodedCharContext) IsEncodedCharContext() {}

func NewEncodedCharContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EncodedCharContext {
	var p = new(EncodedCharContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC5322ParserRULE_encodedChar

	return p
}

func (s *EncodedCharContext) GetParser() antlr.Parser { return s.parser }

func (s *EncodedCharContext) Alpha() IAlphaContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlphaContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlphaContext)
}

func (s *EncodedCharContext) Exclamation() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserExclamation, 0)
}

func (s *EncodedCharContext) DQuote() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserDQuote, 0)
}

func (s *EncodedCharContext) Hash() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserHash, 0)
}

func (s *EncodedCharContext) Dollar() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserDollar, 0)
}

func (s *EncodedCharContext) Percent() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserPercent, 0)
}

func (s *EncodedCharContext) Ampersand() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserAmpersand, 0)
}

func (s *EncodedCharContext) SQuote() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserSQuote, 0)
}

func (s *EncodedCharContext) LParens() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserLParens, 0)
}

func (s *EncodedCharContext) RParens() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserRParens, 0)
}

func (s *EncodedCharContext) Asterisk() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserAsterisk, 0)
}

func (s *EncodedCharContext) Plus() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserPlus, 0)
}

func (s *EncodedCharContext) Comma() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserComma, 0)
}

func (s *EncodedCharContext) Minus() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserMinus, 0)
}

func (s *EncodedCharContext) Period() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserPeriod, 0)
}

func (s *EncodedCharContext) Slash() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserSlash, 0)
}

func (s *EncodedCharContext) Digit() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserDigit, 0)
}

func (s *EncodedCharContext) Colon() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserColon, 0)
}

func (s *EncodedCharContext) Semicolon() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserSemicolon, 0)
}

func (s *EncodedCharContext) Less() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserLess, 0)
}

func (s *EncodedCharContext) Equal() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserEqual, 0)
}

func (s *EncodedCharContext) Greater() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserGreater, 0)
}

func (s *EncodedCharContext) At() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserAt, 0)
}

func (s *EncodedCharContext) LBracket() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserLBracket, 0)
}

func (s *EncodedCharContext) Backslash() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserBackslash, 0)
}

func (s *EncodedCharContext) RBracket() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserRBracket, 0)
}

func (s *EncodedCharContext) Caret() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserCaret, 0)
}

func (s *EncodedCharContext) Underscore() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserUnderscore, 0)
}

func (s *EncodedCharContext) Backtick() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserBacktick, 0)
}

func (s *EncodedCharContext) LCurly() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserLCurly, 0)
}

func (s *EncodedCharContext) Pipe() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserPipe, 0)
}

func (s *EncodedCharContext) RCurly() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserRCurly, 0)
}

func (s *EncodedCharContext) Tilde() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserTilde, 0)
}

func (s *EncodedCharContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EncodedCharContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EncodedCharContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.EnterEncodedChar(s)
	}
}

func (s *EncodedCharContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.ExitEncodedChar(s)
	}
}

func (p *RFC5322Parser) EncodedChar() (localctx IEncodedCharContext) {
	this := p
	_ = this

	localctx = NewEncodedCharContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, RFC5322ParserRULE_encodedChar)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(980)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case RFC5322ParserA, RFC5322ParserB, RFC5322ParserC, RFC5322ParserD, RFC5322ParserE, RFC5322ParserF, RFC5322ParserG, RFC5322ParserH, RFC5322ParserI, RFC5322ParserJ, RFC5322ParserK, RFC5322ParserL, RFC5322ParserM, RFC5322ParserN, RFC5322ParserO, RFC5322ParserP, RFC5322ParserQ, RFC5322ParserR, RFC5322ParserS, RFC5322ParserT, RFC5322ParserU, RFC5322ParserV, RFC5322ParserW, RFC5322ParserX, RFC5322ParserY, RFC5322ParserZ:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(947)
			p.Alpha()
		}

	case RFC5322ParserExclamation:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(948)
			p.Match(RFC5322ParserExclamation)
		}

	case RFC5322ParserDQuote:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(949)
			p.Match(RFC5322ParserDQuote)
		}

	case RFC5322ParserHash:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(950)
			p.Match(RFC5322ParserHash)
		}

	case RFC5322ParserDollar:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(951)
			p.Match(RFC5322ParserDollar)
		}

	case RFC5322ParserPercent:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(952)
			p.Match(RFC5322ParserPercent)
		}

	case RFC5322ParserAmpersand:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(953)
			p.Match(RFC5322ParserAmpersand)
		}

	case RFC5322ParserSQuote:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(954)
			p.Match(RFC5322ParserSQuote)
		}

	case RFC5322ParserLParens:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(955)
			p.Match(RFC5322ParserLParens)
		}

	case RFC5322ParserRParens:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(956)
			p.Match(RFC5322ParserRParens)
		}

	case RFC5322ParserAsterisk:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(957)
			p.Match(RFC5322ParserAsterisk)
		}

	case RFC5322ParserPlus:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(958)
			p.Match(RFC5322ParserPlus)
		}

	case RFC5322ParserComma:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(959)
			p.Match(RFC5322ParserComma)
		}

	case RFC5322ParserMinus:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(960)
			p.Match(RFC5322ParserMinus)
		}

	case RFC5322ParserPeriod:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(961)
			p.Match(RFC5322ParserPeriod)
		}

	case RFC5322ParserSlash:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(962)
			p.Match(RFC5322ParserSlash)
		}

	case RFC5322ParserDigit:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(963)
			p.Match(RFC5322ParserDigit)
		}

	case RFC5322ParserColon:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(964)
			p.Match(RFC5322ParserColon)
		}

	case RFC5322ParserSemicolon:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(965)
			p.Match(RFC5322ParserSemicolon)
		}

	case RFC5322ParserLess:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(966)
			p.Match(RFC5322ParserLess)
		}

	case RFC5322ParserEqual:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(967)
			p.Match(RFC5322ParserEqual)
		}

	case RFC5322ParserGreater:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(968)
			p.Match(RFC5322ParserGreater)
		}

	case RFC5322ParserAt:
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(969)
			p.Match(RFC5322ParserAt)
		}

	case RFC5322ParserLBracket:
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(970)
			p.Match(RFC5322ParserLBracket)
		}

	case RFC5322ParserBackslash:
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(971)
			p.Match(RFC5322ParserBackslash)
		}

	case RFC5322ParserRBracket:
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(972)
			p.Match(RFC5322ParserRBracket)
		}

	case RFC5322ParserCaret:
		p.EnterOuterAlt(localctx, 27)
		{
			p.SetState(973)
			p.Match(RFC5322ParserCaret)
		}

	case RFC5322ParserUnderscore:
		p.EnterOuterAlt(localctx, 28)
		{
			p.SetState(974)
			p.Match(RFC5322ParserUnderscore)
		}

	case RFC5322ParserBacktick:
		p.EnterOuterAlt(localctx, 29)
		{
			p.SetState(975)
			p.Match(RFC5322ParserBacktick)
		}

	case RFC5322ParserLCurly:
		p.EnterOuterAlt(localctx, 30)
		{
			p.SetState(976)
			p.Match(RFC5322ParserLCurly)
		}

	case RFC5322ParserPipe:
		p.EnterOuterAlt(localctx, 31)
		{
			p.SetState(977)
			p.Match(RFC5322ParserPipe)
		}

	case RFC5322ParserRCurly:
		p.EnterOuterAlt(localctx, 32)
		{
			p.SetState(978)
			p.Match(RFC5322ParserRCurly)
		}

	case RFC5322ParserTilde:
		p.EnterOuterAlt(localctx, 33)
		{
			p.SetState(979)
			p.Match(RFC5322ParserTilde)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ICrlfContext is an interface to support dynamic dispatch.
type ICrlfContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCrlfContext differentiates from other interfaces.
	IsCrlfContext()
}

type CrlfContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCrlfContext() *CrlfContext {
	var p = new(CrlfContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFC5322ParserRULE_crlf
	return p
}

func (*CrlfContext) IsCrlfContext() {}

func NewCrlfContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CrlfContext {
	var p = new(CrlfContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC5322ParserRULE_crlf

	return p
}

func (s *CrlfContext) GetParser() antlr.Parser { return s.parser }

func (s *CrlfContext) CR() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserCR, 0)
}

func (s *CrlfContext) LF() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserLF, 0)
}

func (s *CrlfContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CrlfContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CrlfContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.EnterCrlf(s)
	}
}

func (s *CrlfContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.ExitCrlf(s)
	}
}

func (p *RFC5322Parser) Crlf() (localctx ICrlfContext) {
	this := p
	_ = this

	localctx = NewCrlfContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, RFC5322ParserRULE_crlf)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(982)
		p.Match(RFC5322ParserCR)
	}
	{
		p.SetState(983)
		p.Match(RFC5322ParserLF)
	}

	return localctx
}

// IWspContext is an interface to support dynamic dispatch.
type IWspContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWspContext differentiates from other interfaces.
	IsWspContext()
}

type WspContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWspContext() *WspContext {
	var p = new(WspContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFC5322ParserRULE_wsp
	return p
}

func (*WspContext) IsWspContext() {}

func NewWspContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WspContext {
	var p = new(WspContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC5322ParserRULE_wsp

	return p
}

func (s *WspContext) GetParser() antlr.Parser { return s.parser }

func (s *WspContext) SP() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserSP, 0)
}

func (s *WspContext) TAB() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserTAB, 0)
}

func (s *WspContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WspContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WspContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.EnterWsp(s)
	}
}

func (s *WspContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.ExitWsp(s)
	}
}

func (p *RFC5322Parser) Wsp() (localctx IWspContext) {
	this := p
	_ = this

	localctx = NewWspContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, RFC5322ParserRULE_wsp)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(985)
		_la = p.GetTokenStream().LA(1)

		if !(_la == RFC5322ParserTAB || _la == RFC5322ParserSP) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IVcharContext is an interface to support dynamic dispatch.
type IVcharContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVcharContext differentiates from other interfaces.
	IsVcharContext()
}

type VcharContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVcharContext() *VcharContext {
	var p = new(VcharContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFC5322ParserRULE_vchar
	return p
}

func (*VcharContext) IsVcharContext() {}

func NewVcharContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VcharContext {
	var p = new(VcharContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC5322ParserRULE_vchar

	return p
}

func (s *VcharContext) GetParser() antlr.Parser { return s.parser }

func (s *VcharContext) Alpha() IAlphaContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlphaContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlphaContext)
}

func (s *VcharContext) Exclamation() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserExclamation, 0)
}

func (s *VcharContext) DQuote() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserDQuote, 0)
}

func (s *VcharContext) Hash() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserHash, 0)
}

func (s *VcharContext) Dollar() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserDollar, 0)
}

func (s *VcharContext) Percent() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserPercent, 0)
}

func (s *VcharContext) Ampersand() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserAmpersand, 0)
}

func (s *VcharContext) SQuote() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserSQuote, 0)
}

func (s *VcharContext) LParens() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserLParens, 0)
}

func (s *VcharContext) RParens() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserRParens, 0)
}

func (s *VcharContext) Asterisk() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserAsterisk, 0)
}

func (s *VcharContext) Plus() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserPlus, 0)
}

func (s *VcharContext) Comma() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserComma, 0)
}

func (s *VcharContext) Minus() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserMinus, 0)
}

func (s *VcharContext) Period() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserPeriod, 0)
}

func (s *VcharContext) Slash() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserSlash, 0)
}

func (s *VcharContext) Digit() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserDigit, 0)
}

func (s *VcharContext) Colon() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserColon, 0)
}

func (s *VcharContext) Semicolon() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserSemicolon, 0)
}

func (s *VcharContext) Less() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserLess, 0)
}

func (s *VcharContext) Equal() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserEqual, 0)
}

func (s *VcharContext) Greater() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserGreater, 0)
}

func (s *VcharContext) Question() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserQuestion, 0)
}

func (s *VcharContext) At() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserAt, 0)
}

func (s *VcharContext) LBracket() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserLBracket, 0)
}

func (s *VcharContext) Backslash() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserBackslash, 0)
}

func (s *VcharContext) RBracket() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserRBracket, 0)
}

func (s *VcharContext) Caret() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserCaret, 0)
}

func (s *VcharContext) Underscore() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserUnderscore, 0)
}

func (s *VcharContext) Backtick() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserBacktick, 0)
}

func (s *VcharContext) LCurly() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserLCurly, 0)
}

func (s *VcharContext) Pipe() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserPipe, 0)
}

func (s *VcharContext) RCurly() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserRCurly, 0)
}

func (s *VcharContext) Tilde() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserTilde, 0)
}

func (s *VcharContext) UTF8NonAscii() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserUTF8NonAscii, 0)
}

func (s *VcharContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VcharContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VcharContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.EnterVchar(s)
	}
}

func (s *VcharContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.ExitVchar(s)
	}
}

func (p *RFC5322Parser) Vchar() (localctx IVcharContext) {
	this := p
	_ = this

	localctx = NewVcharContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, RFC5322ParserRULE_vchar)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1022)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case RFC5322ParserA, RFC5322ParserB, RFC5322ParserC, RFC5322ParserD, RFC5322ParserE, RFC5322ParserF, RFC5322ParserG, RFC5322ParserH, RFC5322ParserI, RFC5322ParserJ, RFC5322ParserK, RFC5322ParserL, RFC5322ParserM, RFC5322ParserN, RFC5322ParserO, RFC5322ParserP, RFC5322ParserQ, RFC5322ParserR, RFC5322ParserS, RFC5322ParserT, RFC5322ParserU, RFC5322ParserV, RFC5322ParserW, RFC5322ParserX, RFC5322ParserY, RFC5322ParserZ:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(987)
			p.Alpha()
		}

	case RFC5322ParserExclamation:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(988)
			p.Match(RFC5322ParserExclamation)
		}

	case RFC5322ParserDQuote:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(989)
			p.Match(RFC5322ParserDQuote)
		}

	case RFC5322ParserHash:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(990)
			p.Match(RFC5322ParserHash)
		}

	case RFC5322ParserDollar:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(991)
			p.Match(RFC5322ParserDollar)
		}

	case RFC5322ParserPercent:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(992)
			p.Match(RFC5322ParserPercent)
		}

	case RFC5322ParserAmpersand:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(993)
			p.Match(RFC5322ParserAmpersand)
		}

	case RFC5322ParserSQuote:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(994)
			p.Match(RFC5322ParserSQuote)
		}

	case RFC5322ParserLParens:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(995)
			p.Match(RFC5322ParserLParens)
		}

	case RFC5322ParserRParens:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(996)
			p.Match(RFC5322ParserRParens)
		}

	case RFC5322ParserAsterisk:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(997)
			p.Match(RFC5322ParserAsterisk)
		}

	case RFC5322ParserPlus:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(998)
			p.Match(RFC5322ParserPlus)
		}

	case RFC5322ParserComma:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(999)
			p.Match(RFC5322ParserComma)
		}

	case RFC5322ParserMinus:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(1000)
			p.Match(RFC5322ParserMinus)
		}

	case RFC5322ParserPeriod:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(1001)
			p.Match(RFC5322ParserPeriod)
		}

	case RFC5322ParserSlash:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(1002)
			p.Match(RFC5322ParserSlash)
		}

	case RFC5322ParserDigit:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(1003)
			p.Match(RFC5322ParserDigit)
		}

	case RFC5322ParserColon:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(1004)
			p.Match(RFC5322ParserColon)
		}

	case RFC5322ParserSemicolon:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(1005)
			p.Match(RFC5322ParserSemicolon)
		}

	case RFC5322ParserLess:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(1006)
			p.Match(RFC5322ParserLess)
		}

	case RFC5322ParserEqual:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(1007)
			p.Match(RFC5322ParserEqual)
		}

	case RFC5322ParserGreater:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(1008)
			p.Match(RFC5322ParserGreater)
		}

	case RFC5322ParserQuestion:
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(1009)
			p.Match(RFC5322ParserQuestion)
		}

	case RFC5322ParserAt:
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(1010)
			p.Match(RFC5322ParserAt)
		}

	case RFC5322ParserLBracket:
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(1011)
			p.Match(RFC5322ParserLBracket)
		}

	case RFC5322ParserBackslash:
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(1012)
			p.Match(RFC5322ParserBackslash)
		}

	case RFC5322ParserRBracket:
		p.EnterOuterAlt(localctx, 27)
		{
			p.SetState(1013)
			p.Match(RFC5322ParserRBracket)
		}

	case RFC5322ParserCaret:
		p.EnterOuterAlt(localctx, 28)
		{
			p.SetState(1014)
			p.Match(RFC5322ParserCaret)
		}

	case RFC5322ParserUnderscore:
		p.EnterOuterAlt(localctx, 29)
		{
			p.SetState(1015)
			p.Match(RFC5322ParserUnderscore)
		}

	case RFC5322ParserBacktick:
		p.EnterOuterAlt(localctx, 30)
		{
			p.SetState(1016)
			p.Match(RFC5322ParserBacktick)
		}

	case RFC5322ParserLCurly:
		p.EnterOuterAlt(localctx, 31)
		{
			p.SetState(1017)
			p.Match(RFC5322ParserLCurly)
		}

	case RFC5322ParserPipe:
		p.EnterOuterAlt(localctx, 32)
		{
			p.SetState(1018)
			p.Match(RFC5322ParserPipe)
		}

	case RFC5322ParserRCurly:
		p.EnterOuterAlt(localctx, 33)
		{
			p.SetState(1019)
			p.Match(RFC5322ParserRCurly)
		}

	case RFC5322ParserTilde:
		p.EnterOuterAlt(localctx, 34)
		{
			p.SetState(1020)
			p.Match(RFC5322ParserTilde)
		}

	case RFC5322ParserUTF8NonAscii:
		p.EnterOuterAlt(localctx, 35)
		{
			p.SetState(1021)
			p.Match(RFC5322ParserUTF8NonAscii)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IAlphaContext is an interface to support dynamic dispatch.
type IAlphaContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAlphaContext differentiates from other interfaces.
	IsAlphaContext()
}

type AlphaContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlphaContext() *AlphaContext {
	var p = new(AlphaContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFC5322ParserRULE_alpha
	return p
}

func (*AlphaContext) IsAlphaContext() {}

func NewAlphaContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlphaContext {
	var p = new(AlphaContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFC5322ParserRULE_alpha

	return p
}

func (s *AlphaContext) GetParser() antlr.Parser { return s.parser }

func (s *AlphaContext) A() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserA, 0)
}

func (s *AlphaContext) B() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserB, 0)
}

func (s *AlphaContext) C() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserC, 0)
}

func (s *AlphaContext) D() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserD, 0)
}

func (s *AlphaContext) E() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserE, 0)
}

func (s *AlphaContext) F() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserF, 0)
}

func (s *AlphaContext) G() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserG, 0)
}

func (s *AlphaContext) H() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserH, 0)
}

func (s *AlphaContext) I() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserI, 0)
}

func (s *AlphaContext) J() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserJ, 0)
}

func (s *AlphaContext) K() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserK, 0)
}

func (s *AlphaContext) L() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserL, 0)
}

func (s *AlphaContext) M() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserM, 0)
}

func (s *AlphaContext) N() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserN, 0)
}

func (s *AlphaContext) O() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserO, 0)
}

func (s *AlphaContext) P() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserP, 0)
}

func (s *AlphaContext) Q() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserQ, 0)
}

func (s *AlphaContext) R() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserR, 0)
}

func (s *AlphaContext) S() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserS, 0)
}

func (s *AlphaContext) T() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserT, 0)
}

func (s *AlphaContext) U() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserU, 0)
}

func (s *AlphaContext) V() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserV, 0)
}

func (s *AlphaContext) W() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserW, 0)
}

func (s *AlphaContext) X() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserX, 0)
}

func (s *AlphaContext) Y() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserY, 0)
}

func (s *AlphaContext) Z() antlr.TerminalNode {
	return s.GetToken(RFC5322ParserZ, 0)
}

func (s *AlphaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlphaContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlphaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.EnterAlpha(s)
	}
}

func (s *AlphaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFC5322ParserListener); ok {
		listenerT.ExitAlpha(s)
	}
}

func (p *RFC5322Parser) Alpha() (localctx IAlphaContext) {
	this := p
	_ = this

	localctx = NewAlphaContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, RFC5322ParserRULE_alpha)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1024)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-45)&-(0x1f+1)) == 0 && ((1<<uint((_la-45)))&((1<<(RFC5322ParserA-45))|(1<<(RFC5322ParserB-45))|(1<<(RFC5322ParserC-45))|(1<<(RFC5322ParserD-45))|(1<<(RFC5322ParserE-45))|(1<<(RFC5322ParserF-45))|(1<<(RFC5322ParserG-45))|(1<<(RFC5322ParserH-45))|(1<<(RFC5322ParserI-45))|(1<<(RFC5322ParserJ-45))|(1<<(RFC5322ParserK-45))|(1<<(RFC5322ParserL-45))|(1<<(RFC5322ParserM-45))|(1<<(RFC5322ParserN-45))|(1<<(RFC5322ParserO-45))|(1<<(RFC5322ParserP-45))|(1<<(RFC5322ParserQ-45))|(1<<(RFC5322ParserR-45))|(1<<(RFC5322ParserS-45))|(1<<(RFC5322ParserT-45))|(1<<(RFC5322ParserU-45))|(1<<(RFC5322ParserV-45))|(1<<(RFC5322ParserW-45))|(1<<(RFC5322ParserX-45))|(1<<(RFC5322ParserY-45))|(1<<(RFC5322ParserZ-45)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}
